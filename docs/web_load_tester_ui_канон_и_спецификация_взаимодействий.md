# WebLoadTester — UI канон и спецификация взаимодействий

**Версия:** v1.2 03.02.2026\
**Статус:** Канон UI (опора для разработки)\
**Цель документа:** описать интерфейс и поведение приложения настолько подробно, чтобы по одному этому тексту можно было (1) отрисовать макеты и (2) реализовать UI+связи с backend без догадок.

---

## 0) Инварианты проекта (не нарушать)

1. **4 вкладки верхнего уровня:** UI тестирование / HTTP тестирование / Сеть и безопасность / Прогоны.
2. **10 модулей:** A1–A3, B1–B3, C1–C4.
3. **Режимы нагрузки:** только **Iterations** и **Duration** (Stress/Soak не реализуем — только “Перспективы”).
4. **Хранилище:** SQLite + файловая папка `runs/{RunId}/`.
5. **Отчёты:** `report.json` — всегда. `report.html` — по флагу.
6. **Telegram:** опционально. Ошибка Telegram не меняет статус прогона.
7. **Безопасность:** C3 — baseline без атак.

---

## 1) Принятые решения по UX (фиксируем)

### 1.1 Конфигурации (единый UX)

- Пользователь работает с **конфигурацией модуля** как с единым набором настроек.
- Сценарий: **Загрузить конфиг → все поля заполнились/флаги выставились → нажать “Старт”.**
- Пользователь может **сохранить конфиг**, если заполнены обязательные поля.
- **Формат имени при сохранении:** `ИмяКонфига_UIСценарий` (без пробелов). Суффикс всегда добавляется автоматически.
- Конфигурация может иметь **Description**.

### 1.2 Параметры запуска — отдельная секция

- Параметры запуска (Iterations/Duration/Parallelism/Timeout + флаги HTML/Telegram/Preflight + UI-specific) находятся в **отдельной секции “Параметры запуска”**.

### 1.3 Результаты

- В режиме MVP: **Детали = ошибки + агрегаты** (с возможностью “показать всё” позже).

### 1.4 Лог

- Лог — **общий нижний выдвижной блок (drawer)**.
- По умолчанию **скрыт**, пользователь раскрывает при необходимости.
- В лог выводим **лог только текущего запуска** (после завершения — можно очищать при новом запуске).
- Нужен переключатель **“Автоскролл”**.
- Фильтр уровней: **только если уровни уже есть**. В MVP — достаточно “Только ошибки”.

---

## 2) Термины (коротко)

- **Модуль**: функциональный тип теста (A1..C4).
- **Конфигурация модуля**: сохранённые пользовательские настройки конкретного модуля + (опционально) metadata.
- **Параметры запуска**: режим нагрузки/параллельность/таймауты/флаги отчётов и интеграций.
- **Прогон (Run)**: конкретный запуск теста, имеет `RunId`, записи в БД и артефакты в `runs/{RunId}/`.
- **Артефакты**: `report.json`, (опционально `report.html`), `logs/`, `screenshots/`, доп. файлы.

---

## 3) Иерархия экранов (IA) и навигация

### 3.1 Главное окно (MainWindow)

Содержит:

- **App Header** (закреплён сверху)
- **Tab Strip** (4 вкладки)
- **Tab Content** (контент активной вкладки)
- **Log Drawer** (закреплён снизу, скрыт по умолчанию)

### 3.2 Окно “Настройки”

Открывается из App Header. Содержит секции Storage/Telegram.

---

## 4) Layout-канон (без наложений)

### 4.1 Общие правила

- Внутри вкладок используются **Grid + DockPanel + ScrollViewer**.
- Все большие области — вертикальный скролл **только в одной** зоне: `ScrollViewer` в “Body” вкладки.
- Заголовки и панели управления — **закреплены** (не скроллятся).
- Никаких TextBlock поверх TextBox для “плейсхолдера”. Используем `Watermark`.
- Никаких “узких колонок”, где текст превращается в вертикальный столбик.

### 4.2 Три закреплённых ряда внутри вкладки модулей

Для вкладок: UI/HTTP/Сеть.

1. **Run Control Row**: Старт/Перезапуск/Остановить/Отмена + прогресс + стадия.
2. **Module Selection Row**: выбор модуля в строку (без поиска).
3. **Module Info Row**: DisplayName + Description.

Далее — `ScrollViewer` с секциями.

---

## 5) UI спецификация: MainWindow

### 5.1 App Header (закреплён сверху)

**Слева:**

- Заголовок: “WebLoadTester”
- Подзаголовок: “Панель управления”

**Справа (в одну строку):**

- Кнопка `Настройки`
- Кнопка `Папка прогонов`
- Статусы-чипы:
  - `БД: OK/Ошибка`
  - `Telegram: настроен/не настроен`

**События/действия:**

- `Настройки` → открыть окно Settings.
- `Папка прогонов` → открыть каталог storage runs.
- Клик по `Telegram: ...` (опционально) → открыть Settings и проскроллить к секции Telegram.

### 5.2 Tabs (4 вкладки)

1. UI тестирование
2. HTTP тестирование
3. Сеть и безопасность
4. Прогоны

**Требование:** при переключении вкладок не должны “ломаться” введённые данные (сохраняем VM состояние).

### 5.3 Log Drawer (закреплён снизу)

**Свернутый режим (default):**

- Заголовок: “Лог выполнения”
- Кнопка `▲` (развернуть)

**Развернутый режим:**

- Checkbox `Автоскролл` (default ON)
- Checkbox `Только ошибки` (default OFF)
- Кнопки: `Очистить` (очистить текущий лог), `Копировать` (в буфер)
- Список лог-строк (виртуализация или ограничение количества строк, например 5–10k)
- Кнопка `▼` (свернуть)

**Данные:**

- Лог привязан к текущему прогону; при старте нового прогона лог очищается (или делаем кнопку “Сохранить предыдущий” — позже).

---

## 6) Канон экрана модулей (UI/HTTP/Сеть)

### 6.1 Верхняя закреплённая зона (Pinned Header)

#### 6.1.1 Ряд 1 — Run Control

**Элементы:**

- Button `Старт` (Primary)
- Button `Перезапуск`
- Button `Остановить`
- Button `Отмена`
- ProgressBar
- TextBlock “Стадия: …”
- TextBlock “Прогресс: …”

**Логика enabled/disabled:**

- `Старт` enabled когда:
  - `!IsRunning`
  - `ValidationErrors.Count == 0`
- `Перезапуск` enabled когда:
  - `!IsRunning` OR (IsRunning и реализован safe restart)
- `Остановить` enabled когда `IsRunning` (soft-stop)
- `Отмена` enabled когда `IsRunning` (cancel)

**Отображение прогресса:**

- Если total неизвестен → `IsIndeterminate=true`
- Иначе `Value = ProgressPercent`

**Подсказка под прогрессом (не обяз.):**

- “report.json создаётся всегда; report.html — по флагу.”

#### 6.1.2 Ряд 2 — Module Selection (без поиска)

Отображаем горизонтально:

- UI: `UI сценарий | UI снимки | UI тайминги`
- HTTP: `HTTP функциональные | HTTP производительность | HTTP ассеты`
- Сеть: `Диагностика | Доступность | Baseline | Preflight`

#### 6.1.3 Ряд 3 — Module Info

- DisplayName (H3)
- Description (1–2 строки, перенос по словам)

---

### 6.2 Прокручиваемая зона (Body Scroll)

Структура секций:

1. Конфигурация
2. Параметры запуска
3. Настройки модуля
4. Результаты

Каждая секция — Card (Border) с заголовком.

---

## 7) Секция “Конфигурация” (для каждого модуля)

### 7.1 Элементы

- ComboBox `Выберите конфигурацию…` (Watermark)
- Button `Загрузить`
- Button `Сохранить`
- Button `Сохранить как…`
- Button `Удалить`

Поля:

- TextBox `Имя конфигурации` (Watermark: “Например: YandexSearch”) — пользователь вводит базовое имя.
- TextBox `Описание` (опционально, multiline)

### 7.2 Правила имени

При сохранении итоговое имя:

- `FinalName = UserName + "_" + ModuleSuffix` Где `ModuleSuffix` фиксированный:
- A1: `UIСценарий`
- A2: `UISнимки`
- A3: `UITайминги`
- B1: `HTTPФункциональные`
- B2: `HTTPПроизводительность`
- B3: `HTTPАссеты`
- C1: `СетьДиагностика`
- C2: `СетьДоступность`
- C3: `SecurityBaseline`
- C4: `Preflight`

В UI показываем подсказку:

- “Будет сохранено как: {FinalName}”

### 7.3 Поведение кнопок

- `Загрузить`: применяет выбранную конфигурацию:
  - заполняет поля секции “Параметры запуска”
  - заполняет поля “Настройки модуля”
  - выставляет флаги
- `Сохранить`: сохраняет текущие значения в выбранную конфигурацию (если выбрана) либо показывает “Сохраните как”.
- `Сохранить как`: сохраняет в новую запись, имя обязательно.
- `Удалить`: удаляет конфигурацию (с подтверждением).

### 7.4 Валидация

- Если обязательные поля не заполнены — `Сохранить/Старт` блокируются или показывается список ошибок.
- Ошибки выводим в этой секции (например, под кнопками):
  - “StartUrl обязателен”
  - “Добавьте хотя бы 1 шаг”
  - “Iterations должен быть > 0”

---

## 8) Секция “Параметры запуска”

### 8.1 Обязательные поля

- Mode: `Iterations` / `Duration`
- Iterations (если выбран Iterations)
- DurationSeconds (если выбран Duration)
- Parallelism (1..N)
- TimeoutSeconds (минимум 1)

### 8.2 Флаги

- HtmlReportEnabled
- TelegramEnabled
- PreflightEnabled

### 8.3 UI-specific (только для UI вкладки)

- Headless
- ScreenshotsPolicy: Off / OnError / Always

### 8.4 Safe defaults

Если пользователь не заполнил:

- Parallelism → 1
- Iterations → 10
- Duration → 30
- TimeoutSeconds → 30

### 8.5 Warnings

Показываем warning-плашку (не блокирует запуск) при:

- Iterations > 200
- Duration > 300s
- Parallelism > 10 (значения можно уточнить позже)

---

## 9) Секция “Настройки модуля” — A1 UI сценарий (детально)

### 9.1 Общие поля

- StartUrl (TextBox, обязательное)
- (опционально позже) BaseUrl/WaitCondition — не требуется сейчас

### 9.2 Шаги сценария — “карточки шагов”

#### 9.2.1 Список шагов

Отображение: вертикальный список карточек.

#### 9.2.2 Карточка шага (StepCard)

**Header:**

- `Шаг #N`
- Кнопки: `↑` `↓` `Удалить`

**Body:**

1. TextBox `Selector` (обязательное)
2. Переключатель `Действие`: `Клик` / `Ввод`
3. TextBox `Текст` (показывается только при “Ввод”)

**Behavior:**

- Если пользователь вводит текст в поле “Текст” → автоматически выставить “Ввод”.
- Если пользователь переключил действие на “Клик” → поле “Текст” очищается.

**Примеры (как в ТЗ):**

- Шаг 1: Selector `#dc-1247360-input`, Action `Ввод`, Text `Привет`
- Шаг 2: Selector `#app > div... > span`, Action `Клик`, Text скрыт

#### 9.2.3 Кнопки управления списком

- `+ Добавить шаг` (добавляет новый шаг в конец)
- Перемещение вверх/вниз — по кнопкам в карточке.

### 9.3 Валидация A1

- StartUrl не пустой и валидный URL.
- Список шагов не пустой.
- У каждого шага не пустой Selector.
- Если Action=Ввод → Text может быть пустым? (по умолчанию **разрешить пустой**, но лучше предупреждение).

---

## 10) Результаты (общий подход для MVP)

### 10.1 Секция “Результаты”

Одна карточка с внутренними вкладками:

- “Сводка”
- “Детали (ошибки + агрегаты)”
- “Артефакты”

### 10.2 Сводка

- Status (Success/Failed/Cancelled)
- Duration
- ErrorCount
- Key metrics (для A1: количество шагов, успешные/ошибки)

### 10.3 Детали (ошибки + агрегаты)

**Отображаем:**

- Таблица “Ошибки” (если есть)
- Таблица “Агрегаты” (например, total steps, avg step time)

Опционально кнопка: “Показать все события” (позже).

### 10.4 Артефакты

- `Открыть report.json`
- `Открыть report.html` (если создан)
- `Открыть папку прогона`
- Список артефактов (клик — открыть)

---

## 11) Вкладка “Прогоны” (минимальный канон)

### 11.1 Фильтры

- Поиск (по RunId/DisplayName)
- Фильтр по модулю
- Фильтр по статусу

### 11.2 Таблица прогонов

Колонки:

- RunId (копировать)
- StartedAt
- Module
- Status
- Duration
- Errors

### 11.3 Действия

- Открыть JSON
- Открыть HTML (если есть)
- Открыть папку
- Повторить запуск

---

## 12) Настройки (Settings)

### 12.1 Storage paths

Каждый путь — одна строка:

- Label
- ReadOnly TextBox
- Button `Выбрать` (если применимо)
- Button `Открыть`
- Button `Копировать`

Обязательные пути:

- BaseDataDir
- RunsDir
- DatabaseFilePath

### 12.2 Telegram

- Token
- ChatId
- Toggle “Включить Telegram”
- Чекбоксы уведомлений: start / finish / error / progress (progress default OFF)

---

## 13) Связь UI ↔ Backend (контракты и состояния)

### 13.1 Основные VM и роли

- `MainWindowViewModel`:

  - глобальный запуск, прогресс, стадия, команды Start/Stop/Cancel/Restart
  - работа с RunOrchestrator
  - работа с Artifact open
  - управление Log Drawer (log lines)

- `ModuleFamilyViewModel`:

  - выбранный модуль, список модулей в семействе

- `SettingsViewModel`:

  - storage paths, telegram settings

- `RunsTabViewModel`:

  - список прогонов, фильтры, действия

### 13.2 Run lifecycle (стадии)

Стадии (строго):

- Idle
- Preflight (если enabled)
- Running
- Saving
- Done

UI отображает:

- RunStage (строка)
- Progress (percent или indeterminate)
- Лог строками

### 13.3 Команды

- StartCommand → `RunOrchestrator.StartAsync(selectedModule, settings, runProfile, cancellation)`
- StopCommand → мягкая остановка (если поддерживается)
- CancelCommand → `CancellationToken.Cancel()`
- RestartCommand → safe restart sequence

### 13.4 Данные входа/выхода

**Вход:**

- ModuleConfig (из БД) + RunParameters
- ModuleSettings (A1 settings: StartUrl + Steps)

**Выход:**

- Запись `TestRun` в БД (RunId, статус, timestamps, summary)
- Папка `runs/{RunId}/`:
  - `report.json` (always)
  - `report.html` (optional)
  - `logs/run.log`
  - `screenshots/` (если policy)
- Записи `RunItems`, `Artifacts`

---

## 14) Хранилище конфигураций (важно: БД + кроссплатформа)

### 14.1 Почему SQLite

- Требование научного руководителя: “внедрить БД”.
- SQLite кроссплатформенна (Windows/Linux), простая и уже есть в проекте.

### 14.2 Рекомендуемая схема для конфигураций

Добавить таблицу (или использовать существующие сущности, но UX такой):

- `ModuleConfig`:
  - Id (GUID)
  - ModuleKey (A1/B1/...)
  - Name (FinalName)
  - Description
  - SettingsJson (включает ModuleSettings + RunParameters)
  - CreatedAt, UpdatedAt

### 14.3 Экспорт/импорт (опционально, но рекомендовано)

Даже при хранении в БД полезно добавить:

- `Экспорт JSON`
- `Импорт JSON` Это удобно для переносов конфигов между ПК и для демонстрации.

---

## 15) Требования к ограничениям ввода (validation)

### 15.1 Общие

- URL: проверка формата.
- Числа: min/max.
- Пустые обязательные поля: блокировать Старт и Сохранить.

### 15.2 A1 Steps

- Selector обязателен.
- Action обязателен.
- Text обязателен? (MVP: не обязателен, но warning).

---

## 16) Acceptance Criteria (для разработки)

1. Вкладки UI/HTTP/Сеть имеют 3 закреплённых ряда и прокрутку только в body.
2. Вкладка “UI сценарий” имеет:
   - конфиги: load/save/save as/delete
   - отдельную секцию параметров запуска
   - шаги карточками (selector + click/input + text if input)
3. Поля не накладываются, placeholder реализован через Watermark.
4. Лог снизу приложения: скрыт по умолчанию, автоскролл, текущий запуск.
5. После загрузки конфига все поля заполняются, можно сразу нажать “Старт”.
6. После старта создаётся RunId, запись в БД, папка runs/{RunId}/, отчёты.

---

## 17) TODO (позже, не в MVP UI)

- “Показать все события” в деталях.
- Экспорт/импорт конфигов JSON.
- Уровни логирования как фильтр (если расширим логгер).
- Оптимизация виртуализации больших таблиц.

---

## 18) Журнал изменений

- v1.0 03.02.2026 — первичное формирование канона UI и поведения для A1 + общие правила.
- v1.1 03.02.2026 — расширено: подробные пользовательские сценарии, связь UI↔Backend, модель хранения конфигов, правила обработки ошибок, перечень недостающих элементов, список несостыковок и список вопросов.
- v1.2 03.02.2026 — дописано: полный канон UI для всех модулей (A2–C4), единый формат конфигов в SQLite, детализация «Детали vs Лог», список недостающих классов/методов, расширенные guardrails для Codex и чеклист «меньше ошибок после PR».

## 19) Реальное состояние кода (факт, на текущей ветке)

Этот раздел фиксирует **файлы, классы и точки расширения**, чтобы канон UI выше можно было реализовывать без угадываний.

### 19.1 Presentation (Avalonia UI)

**Ключевые View:**

- `Presentation/Views/MainWindow.axaml` — главное окно (вкладки + хедер + область контента).
- `Presentation/Views/ModuleWorkspaceView.axaml` — рабочее место модулей (UI/HTTP/Сеть): список модулей, закреплённая панель запуска, секции, артефакты, детали, лог.
- `Presentation/Views/Tabs/RunsTab.axaml` — вкладка прогонов (история, действия, повтор).
- `Presentation/Views/SettingsWindow.axaml` — окно настроек (Storage + Telegram).

**Ключевые ViewModel (VM):**

- `Presentation/ViewModels/MainWindowViewModel.cs` — «оркестрирует» UI: команды запуска, стадия/прогресс, открытие артефактов, лог, интеграция с `RunOrchestrator`.
- `Presentation/ViewModels/Tabs/ModuleFamilyViewModel.cs` — семейства модулей (UI/HTTP/Net), выбранный модуль, список модулей.
- `Presentation/ViewModels/ModuleItemViewModel.cs` — один модуль в списке; хранит `SettingsVm`, `TestLibrary`, `CurrentRun` (детали/артефакты), метаданные.
- `Presentation/ViewModels/TestLibraryViewModel.cs` — сохранение/загрузка «тестов» (по факту: конфигураций **настройки модуля**) в SQLite.
- `Presentation/ViewModels/RunProfileViewModel.cs` — сохранение/загрузка «профилей запуска» (Iterations/Duration/параллельность/флаги) в SQLite.
- `Presentation/ViewModels/RunsTabViewModel.cs` — список прогонов, фильтры, открыть JSON/HTML/папку, повтор запуска.
- `Presentation/ViewModels/SettingsWindowViewModel.cs` — пути хранения, Telegram, команды выбрать/открыть/копировать.

**Полезные UI-утилиты:**

- `Presentation/Common/Behaviors/AutoScrollBehavior.cs` — автоскролл списка лога (сейчас включается в XAML статически; в каноне нужно сделать переключаемым).

### 19.2 Core (оркестрация, события, отчёты)

- `Core/Services/RunOrchestrator.cs` — основной жизненный цикл прогона:
  - создаёт `RunId`, заводит запись в БД,
  - выполняет preflight (если включён),
  - выполняет модуль (Iterations/Duration),
  - собирает `ModuleReport`,
  - пишет `report.json` (всегда) и `report.html` (по флагу),
  - сохраняет артефакты в `runs/{RunId}/`,
  - возвращает `RunOrchestratorResult`.
- `Core/Services/ProgressBus.cs` — события прогресса (`Stage`, `Current`, `Total`, `Message`).
- `Core/Services/LogBus.cs` — лог-строки (информационные/ошибка) в UI.
- `Core/Reporting/JsonReportWriter.cs`, `Core/Reporting/HtmlReportWriter.cs` — генерация отчётов.
- `Core/Storage/ArtifactStore.cs` — работа с файловыми артефактами (внутри `runs/{RunId}/`).

### 19.3 Infrastructure (SQLite)

- `Infrastructure/Storage/SqliteRunStore.cs` — фасад БД прогонов + репозитории:
  - `ITestRunRepository` (прогоны)
  - `ITestCaseRepository` (тесты/конфиги модулей)
  - `IRunProfileRepository` (профили запуска)

### 19.4 Доменные сущности, которые уже есть

- `Core/Domain/RunEntities.cs`: `TestRun`, `TestCase`, `TestCaseVersion`, `RunProfile`.
- `Core/Contracts/*Repository.cs`: контракты БД.

### 19.5 Модули (в текущем проекте)

В проекте существует 10 модулей (A1–C4). Для каждого есть:

- настройки (settings-модель в `Modules/*/*.cs`),
- VM настроек в `Presentation/ViewModels/SettingsViewModels/*SettingsViewModel.cs`,
- исполнение через `ITestModule.ExecuteAsync(...)`.

Важно: **канон UI (этот документ) является приоритетом**, даже если текущий код/старые docs описывают иначе. Несовпадения перечислены ниже.

---

## 20) Пользовательские сценарии (что делает пользователь и как отвечает программа)

Ниже — «сквозные сценарии» (user journeys). В каждом: шаги пользователя → реакция UI → какие слои кода задействованы.

### 20.1 Первый запуск приложения

**Пользователь:**

1. Запускает приложение.
2. Видит хедер с состояниями `БД` и `Telegram`.

**UI отвечает:**

- Показывает вкладки (4 шт.).
- В хедере показывает `БД: OK` если SQLite доступна; иначе `БД: Ошибка` + короткая причина.
- `Telegram: не настроен` если токен/чат не заданы.

**Backend:**

- `SqliteRunStore` и репозитории инициализируются.
- `MainWindowViewModel` создаёт семейства модулей и привязывает `RunOrchestrator`.

### 20.2 Настройка путей хранения (Storage)

**Пользователь:**

1. Нажимает `Настройки`.
2. В секции Storage выбирает директорию данных.

**UI отвечает:**

- Открывает `SettingsWindow`.
- Для каждого пути показывает ReadOnly поле + кнопки `Выбрать/Открыть/Копировать`.
- При выборе директории — обновляет отображаемые пути (включая `runs/` и путь к БД).

**Backend:**

- `SettingsWindowViewModel.SelectDataDirCommand` → выбор директории через `IStorageProvider`.
- Пересчёт `RunsDirectory` и `DatabasePath`.
- Сохранение настроек (если предусмотрено) в локальный конфиг приложения.

### 20.3 Настройка Telegram

**Пользователь:**

1. В `Настройки → Telegram` вводит Token и ChatId.
2. Включает `Включить Telegram`.
3. Выставляет чекбоксы уведомлений.

**UI отвечает:**

- Валидирует (не пусто) и показывает статус в хедере (`Telegram: настроен/не настроен`).
- Ошибки Telegram **не блокируют** запуск модулей.

**Backend:**

- Настройки сохраняются в конфиг (или БД, если решим хранить там).
- Во время прогона `RunOrchestrator`/интеграционный слой отправляет уведомления, ошибки логируются через `LogBus`.

### 20.4 Работа с конфигурацией модуля (целевой UX)

> ЦЕЛЬ: «Заполнил всё → сохранил → позже загрузил → нажал Старт». Конфиг включает **настройки модуля + параметры запуска**.

**Пользователь:**

1. Выбирает модуль (например, `UI сценарий`).
2. Заполняет секции: «Настройки модуля» + «Параметры запуска».
3. Нажимает `Сохранить как…`, вводит `ИмяКонфига` без пробелов.

**UI отвечает:**

- Подсказывает финальное имя: `ИмяКонфига_UIСценарий`.
- Если обязательные поля не заполнены — блокирует сохранение и показывает список ошибок.
- После сохранения — конфиг появляется в выпадающем списке.

**Backend (минимальная реализация поверх существующей БД):**

- Используем `ITestCaseRepository` и таблицы `TestCase/TestCaseVersion`.
- В `PayloadJson` сохраняем «обёртку»:
  - `ModuleSettings` (настройки модуля)
  - `RunParameters` (параметры запуска)
  - `Meta` (Description, CreatedAt)
- Технически это можно реализовать как один JSON, без изменения схемы SQLite.

### 20.5 Загрузка конфигурации и запуск

**Пользователь:**

1. Выбирает конфиг в секции «Конфигурация».
2. Нажимает `Загрузить`.
3. Нажимает `Старт`.

**UI отвечает:**

- После `Загрузить` все поля секций заполняются.
- `Старт` становится активен только если валидация OK.
- При старте:
  - кнопки/состояния переключаются (`Старт` disabled, `Остановить/Отмена` enabled),
  - прогресс-бар активируется,
  - нижний лог доступен (по умолчанию скрыт).

**Backend (последовательность вызовов, упрощённо):**

- `MainWindowViewModel.StartCommand` → `StartAsync()`
- `RunOrchestrator.StartAsync(module, settings, runProfile, token)`
- `ITestRunRepository.CreateRunAsync(...)`
- (если включён) `Preflight` → `ITestModule.ExecutePreflightAsync(...)`
- `ITestModule.ExecuteAsync(...)` в цикле Iterations или по таймеру Duration
- `JsonReportWriter.WriteAsync(...)` (+ `HtmlReportWriter` по флагу)
- `ITestRunRepository.UpdateRunAsync(...)`
- UI получает события прогресса через `ProgressBus` и строки логов через `LogBus`.

### 20.6 Останов / Отмена / Перезапуск

**Пользователь:**

- `Остановить` — мягкая остановка (если поддержана модулем/оркестратором).
- `Отмена` — немедленная отмена (CancellationToken).
- `Перезапуск` — безопасная последовательность «Отмена → дождаться завершения → старт снова».

**UI отвечает:**

- При отмене/останове корректно завершает прогресс и фиксирует статус прогона.
- Лог и детали остаются доступными до следующего старта.

**Backend:**

- `CancelCommand` → `CancellationTokenSource.Cancel()`
- `StopCommand` → если есть поддержка soft-stop, сигнализируем модулю; иначе трактуем как cancel.
- `RestartCommand` → safe restart sequence (уже реализовано в VM, но канон требует строгого UX: без гонок и двойных запусков).

### 20.7 Просмотр результатов текущего прогона

**Пользователь:**

1. После завершения смотрит секцию «Результаты».
2. Открывает `report.json` или `report.html`.
3. Открывает папку прогона.

**UI отвечает:**

- Показывает «Сводку» и «Детали (ошибки + агрегаты)».
- Список артефактов кликабелен.

**Backend:**

- Артефакты берутся из `runs/{RunId}/`.
- `MainWindowViewModel.OpenArtifactCommand` открывает файл/директорию через `ProcessStart`/`IPlatform` слой.

### 20.8 История прогонов и повтор запуска (вкладка «Прогоны»)

**Пользователь:**

1. Открывает вкладку «Прогоны».
2. Находит прогон по RunId/модулю/статусу.
3. Нажимает `Повторить запуск`.

**UI отвечает:**

- Подтягивает snapshot (настройки модуля + параметры запуска) из записи прогона.
- Переключает пользователя на нужную вкладку и модуль.
- Заполняет поля и предлагает нажать `Старт` (или запускает сразу — решение уточняем).

**Backend:**

- `RunsTabViewModel.RepeatRunAsync` → читает Run, его `ProfileSnapshotJson`, и применяет в `MainWindowViewModel`.

---

## 21) Каноническая структура экрана модуля (с привязкой к VM и состояниям)

### 21.1 Три закреплённых ряда (Pinned Header)

**Ряд 1 — Run Control Row**

- UI элементы: `Старт / Перезапуск / Остановить / Отмена` + `ProgressBar` + `Stage/ProgressText`.
- Привязки (целевой контракт):
  - `IsRunning` (bool)
  - `RunStage` (string)
  - `ProgressPercent` (double, 0..100)
  - `IsProgressIndeterminate` (bool)
  - `ProgressText` (string)
  - `StartCommand / RestartCommand / StopCommand / CancelCommand`

**Ряд 2 — Module Selection Row (без поиска)**

- Горизонтальные кнопки/сегменты для модулей текущей вкладки.
- Привязка: `ModuleFamilyViewModel.SelectedModule`.

**Ряд 3 — Module Info Row**

- `SelectedModule.DisplayName` и `SelectedModule.Description`.

### 21.2 Прокручиваемая область (Body)

Секции (Cards):

1. Конфигурация
2. Параметры запуска
3. Настройки модуля
4. Результаты

### 21.3 Нижний Log Drawer (общий для приложения)

- Привязка к `MainWindowViewModel.LogLines`.
- Переключатели:
  - `LogAutoScroll` (НУЖНО добавить в VM и связать с `AutoScrollBehavior.IsEnabled`)
  - `LogOnlyErrors` (уже есть частично)

---

## 22) Дизайн конфигураций (как сделать просто, в SQLite, кроссплатформенно)

Требование пользователя: **одна сущность “Конфигурация модуля”** (включает настройки модуля + параметры запуска). Хранение — в БД (SQLite) и должно работать на Windows/Linux.

### 22.1 Рекомендованный «минимальный» вариант (без изменений схемы БД)

Используем существующие таблицы `TestCase/TestCaseVersion`.

- `TestCase.Name` = `ИмяКонфига_СуффиксМодуля` (без пробелов)
- `TestCase.Description` = описание конфигурации
- `TestCaseVersion.PayloadJson` = JSON-обёртка:

```json
{
  "moduleKey": "A1",
  "moduleSettings": { /* текущие настройки A1 */ },
  "runParameters": { /* Iterations/Duration/Parallelism/Timeout + флаги */ },
  "meta": {
    "userName": "ИмяКонфига",
    "finalName": "ИмяКонфига_UIСценарий",
    "description": "...",
    "createdAt": "2026-02-03T13:00:00Z"
  }
}
```

**Плюсы:**

- максимально быстро,
- никаких миграций SQLite,
- UI можно переписать под «единый конфиг», не ломая инфраструктуру.

### 22.2 Альтернатива (чистая модель) — таблица ModuleConfig

Если хочется «идеально», добавляем таблицу `ModuleConfig` и кладём в неё `SettingsJson`. Это чище концептуально, но требует миграции.

### 22.3 Импорт/экспорт (опционально, но сильно полезно)

Даже при хранении в БД добавляем две кнопки:

- `Экспорт JSON`
- `Импорт JSON`

Это облегчает перенос конфигов между ПК, ревью и демонстрации на защите.

---

## 23) Результаты: “Детали” vs “Лог снизу” (что где показываем)

### 23.1 Лог снизу (только текущий запуск)

- Это **потоковые сообщения** во время выполнения.
- Источник: `LogBus` → `MainWindowViewModel` → `LogLines`.
- По умолчанию скрыт, раскрывается пользователем.

### 23.2 Детали (ошибки + агрегаты)

- Это **структурированные элементы результата** (summary + items), полученные из `ModuleReport` и/или сохранённые в БД.
- В MVP показываем:
  - таблицу ошибок,
  - таблицу агрегатов (counts, percentiles, timings — по модулю).
- Источник: `RunOrchestratorResult.Report` / `ModuleItemViewModel.CurrentRun.DisplayResults`.

**Примечание по текущему коду:** сейчас в `ModuleItemViewModel` в детали попадает «первые N результатов» без разделения на ошибки/агрегаты. Канон требует переразметки.

---

## 24) Нереализованные, но нужные элементы (чеклист разработки)

### 24.1 UI/UX

- Убрать “Test Library” и “Run Profile” как 2 отдельные сущности на экране; заменить на **одну секцию “Конфигурация”** (см. §7) и секцию “Параметры запуска” (см. §8), где всё сохраняется/загружается одним действием.
- Убрать поиск модулей; заменить на **горизонтальный выбор модулей** (Pinned Row 2).
- Перенести DisplayName/Description в закреплённый ряд 3; исключить ситуации, когда текст превращается в «вертикальную колонку».
- Сделать Log Drawer скрытым по умолчанию и добавить переключатель `Автоскролл`.
- Привести все поля к одному канону `field-row + field-control` и использовать `Watermark` вместо TextBlock-плейсхолдеров.

### 24.2 A1 UI сценарий (целевой функционал по твоему описанию)

- В UI шага должно быть достаточно:
  - `Selector` (обяз.)
  - `Text` (опционально)
- Правило: если `Text` заполнен → это **ввод**; иначе → **клик**.
- Внутри исполнения можно оставить enum `StepAction`, но UI не должен заставлять пользователя выбирать действие.

### 24.3 Backend/сервисы

- Добавить “обёртку конфигурации” (см. §22.1) и методы:
  - `LoadConfigAsync(name)` → применить `moduleSettings + runParameters`.
  - `SaveConfigAsync(name, description, moduleSettings, runParameters)`.
- Добавить `LogAutoScroll` в `MainWindowViewModel` и привязать к `AutoScrollBehavior.IsEnabled`.
- Валидации (общие + модульные) должны быть единообразны и блокировать `Старт/Сохранить`.

---

## 25) Несостыковки с источниками (сообщаю, но канон оставляю текущим)

1. **Старые docs/01 и docs/03** описывают два раздельных блока: “Test Library” и “Run Profile”.

   - В текущем каноне они объединены в **единый конфиг модуля** + отдельная секция “Параметры запуска”, сохраняемые вместе.

2. В текущем коде `ModuleWorkspaceView` содержит левый список модулей + поиск.

   - В текущем каноне: горизонтальный выбор модулей (Pinned Row 2) и поиск убираем.

3. В коде A1 шаги поддерживают больше типов (`WaitForSelector`, `Click`, `TypeText`, …).

   - В текущем каноне: MVP-функционал **только** “клик” и “ввод текста”, где действие выводится автоматически из заполненности `Text`.

4. В некоторых VM настроек модулей встречаются параметры нагрузки (например, `TotalRuns/Concurrency`), которые дублируют “Параметры запуска”.

   - В текущем каноне: режим нагрузки живёт только в “Параметры запуска”. Нужна унификация.

---

## 26) Вопросы, где нужно твоё решение (без них нельзя «закрыть» UI до конца)

1. **Повтор запуска из “Прогоны”:**

   - вариант A: при нажатии “Повторить” просто заполняем экран и ждём `Старт`;
   - вариант B: сразу стартуем. Что выбираем?

2. **Preflight:**

   - если preflight упал, статус прогона считаем `Failed` или отдельный `PreflightFailed`?

3. **Хранение конфигов:**

   - подтверждаешь минимальный вариант §22.1 (всё в `TestCaseVersion.PayloadJson`) или хочешь отдельную таблицу `ModuleConfig`?

4. **Валидации “URL”:**

   - строгая (только абсолютные `http/https`) или допускаем относительные/без схемы?

5. **Пороговые предупреждения нагрузки:**

   - какие значения считать “опасными” для Iterations/Duration/Parallelism в MVP?

6. **Результаты:**

   - какие агрегаты обязательно показывать в “Детали” для A1 (например: total steps, failed steps, avg step time, p95 step time)?

---

## 27) Типовые ошибки IDE и «условия для Codex» (встроить в рабочий процесс)

Это не про дизайн, а про то, чтобы Codex меньше ломал сборку.

### 27.1 Типовые ошибки, которые уже встречались

- Avalonia XAML:
  - `SetterTargetType` / WPF-атрибуты в Avalonia XAML.
  - `ElementName=...` при отсутствии `x:Name`.
  - биндинги в DataTemplate без `x:DataType` → компилятор видит `object?` и ругается `property ... does not exist on object?`.
  - неправильный DataContext (например, внутри `Border` биндимся как будто на VM).
- .NET build:
  - дубли `AssemblyInfo`/`TargetFrameworkAttribute` из-за ручных Assembly атрибутов + автогенерации.
- Tests:
  - `Fact`/`Xunit` не найдено — не отмечен тестовый проект и/или не добавлены пакеты.

### 27.2 Непробиваемые правила для Codex

1. **Никогда не добавлять WPF-атрибуты** (`SetterTargetType`, `VerticalAlignment` без контекста Avalonia, и т.п.). Только Avalonia-синтаксис.
2. Любой новый/изменённый XAML:
   - обязателен `x:DataType` там, где возможно,
   - если используется `ElementName=Root` — обязателен `x:Name="Root"`.
3. Если добавляем/меняем биндинги в DataTemplate:
   - явно указывать тип элемента,
   - избегать магии `DataContext.` у доменных моделей.
4. Не трогать `obj/` и не добавлять Assembly-атрибуты руками, если включена автогенерация.
5. Любое изменение UI обязано:
   - собираться без ошибок XAML-компилятора,
   - не создавать наложения текста (проверка `field-row/field-control`).

### 27.3 Локальная практика (чтобы после Codex меньше чинить)

- После мержа ветки Codex: `dotnet clean` → `dotnet build`.
- Если IDE показывает странные XAML-ошибки: очистить кеши (bin/obj) и пересобрать.
- UI-изменения делать маленькими PR/ветками: «одна задача — один PR».

---

## 28) Что мне нужно от тебя, чтобы дописать канон для остальных модулей

Чтобы спецификация была “полной для отрисовки и реализации”, по каждому модулю нужны 5 пунктов:

1. **Список полей настроек** (название, тип, обязательность, дефолты).
2. **Ограничения/валидации** (min/max, формат, допустимые значения).
3. **Что считается успехом/ошибкой** (какие ошибки показываем в «Детали»).
4. **Какие артефакты модуль создаёт** (скриншоты, json-ответы, csv, и т.д.).
5. **Ключевые агрегаты** (что важно видеть в «Сводке/Деталях»).

Минимально для продолжения мне достаточно твоего описания для модулей:

- A2 UI снимки
- A3 UI тайминги
- B1 HTTP функциональные
- B2 HTTP производительность
- B3 HTTP ассеты
- C1 Сеть диагностика
- C2 Доступность
- C3 Security baseline
- C4 Preflight

---

## 29) Канон UI по всем модулям (A2–C4)

Ниже — **что именно рисуем и как работает** для каждого модуля. Общий каркас (Pinned Header + 4 секции + Log Drawer) — одинаковый, различается только содержимое секции **«Настройки модуля»** и набор агрегатов/деталей.

### 29.1 A2 — UI снимки

**Назначение:** пройти список URL и сделать скриншоты «состояния страницы».

**Настройки модуля (секция):**

- `UrlList` — список URL (обяз.). UI: многострочный TextBox (по 1 URL на строку) + кнопки:
  - `Нормализовать` (убрать пустые строки, trim)
  - `Проверить` (быстрая валидация URL)
- `WaitCondition` (enum, default: `Load`) — как ждать готовность:
  - `Load` / `DOMContentLoaded` / `NetworkIdle` (если поддержано) / `Selector` (если выбран — появляется поле Selector)
- `ReadySelector` (string) — показывается только при WaitCondition=Selector.
- `MaxWaitSeconds` (int, default 30, min 1, max 300)

**Валидации:**

- хотя бы 1 URL;
- URL абсолютный http/https (в MVP) — если пользователь ввёл без схемы, UI предлагает “добавить https\://”.

**Артефакты:**

- `screenshots/{index}_{host}.png` (или .jpg) — по 1 на URL;
- `logs/run.log`.

**Сводка (обяз. агрегаты):**

- TotalPages, SuccessPages, FailedPages
- AvgLoadMs (если измеряем), TotalDuration

**Детали (ошибки + агрегаты):**

- Ошибки: URL, стадия, текст ошибки
- Агрегаты: min/max/avg loadTime (если доступно)

---

### 29.2 A3 — UI тайминги

**Назначение:** замер времени загрузки страниц по списку URL, несколько повторов (повторы задаются режимом запуска).

**Настройки модуля:**

- `UrlList` — список URL (обяз.) (как в A2)
- `WaitCondition` + `ReadySelector` + `MaxWaitSeconds` — как в A2
- `CollectTimings` (bool, default ON) — собирать метрики

**Особое правило метрик:**

- p95/p99 показывать только если `N >= 20` (иначе только min/max/avg).

**Артефакты:**

- `report.json` (timings)
- (опционально) `timings.csv` — позже

**Сводка:**

- N (кол-во измерений), SuccessRate
- AvgLoadMs, MinLoadMs, MaxLoadMs
- P95/P99 (если N>=20)

**Детали:**

- Ошибки: URL, попытка #, ошибка
- Агрегаты: как в сводке + распределение (позже)

---

### 29.3 B1 — HTTP функциональные

**Назначение:** проверить список endpoint на статус-код и (опционально) наличие текста.

**Настройки модуля:**

- `Endpoints` — список (обяз.). UI: DataGrid/список строк с кнопками Add/Delete:
  - Method (GET/POST/PUT/DELETE/HEAD)
  - Url (обяз.)
  - ExpectedStatus (обяз., default 200)
  - ContainsText (опц.)
- `FollowRedirects` (bool, default ON)

**Валидации:**

- хотя бы 1 endpoint;
- URL валиден;
- ExpectedStatus 100..599.

**Артефакты:**

- только `report.json` + `run.log` (в MVP).

**Сводка:**

- Total, Passed, Failed
- AvgLatencyMs (если измеряем)

**Детали:**

- Ошибки: Method, Url, Expected, Actual, Error
- Агрегаты: successRate

---

### 29.4 B2 — HTTP производительность (контролируемая)

**Назначение:** измерить задержки/успешность под параллельностью и режимом Iterations/Duration.

**Настройки модуля:**

- `BaseUrl` (обяз.) — базовый URL (например, [https://example.com](https://example.com))
- `Path` (обяз.) — путь (например, /api/ping) **или** список endpoints (в MVP лучше 1 endpoint)
- `Method` (default GET)
- `Payload` (опц., только для POST/PUT)
- `Headers` (опц., позже)

**Связь с параметрами запуска:**

- `Parallelism` = количество воркеров (из секции “Параметры запуска”)
- `Iterations/Duration` = режим нагрузки
- `TimeoutSeconds` = таймаут запроса

**Артефакты:**

- `report.json` (summary + latency stats)

**Сводка:**

- RequestsTotal, RequestsOk, RequestsFailed
- Rps (если Duration), AvgLatency, Min/Max
- P95/P99 если N>=20

**Детали:**

- Ошибки: причина (timeout/network/status)
- Агрегаты: как в сводке

---

### 29.5 B3 — HTTP ассеты

**Назначение:** проверить, что статические ассеты доступны и укладываются в ограничения.

**Настройки модуля:**

- `Assets` — список URL (обяз.), UI: многострочный список или DataGrid
- `ExpectedContentType` (опц.)
- `MaxSizeKb` (опц.)
- `MaxLatencyMs` (опц.)

**Валидации:**

- хотя бы 1 URL;
- если задан MaxSize/MaxLatency — >0.

**Сводка:**

- TotalAssets, Passed, Failed

**Детали:**

- Ошибки: URL, проблема (status/content-type/size/latency)
- Агрегаты: avg latency

---

### 29.6 C1 — Сетевая диагностика (DNS/TCP/TLS)

**Назначение:** базовые проверки доступности хоста.

**Настройки модуля:**

- `Target` — host или URL (обяз.)
- `Ports` (по умолчанию: 80, 443)
- Флаги проверок:
  - DNS resolve (default ON)
  - TCP connect (default ON)
  - TLS handshake (default ON если https/443)
  - Cert info (default ON если TLS)

**Сводка:**

- DNS: OK/FAIL
- TCP: OK/FAIL
- TLS: OK/FAIL
- CertDaysLeft (если применимо)

**Детали:**

- Ошибки: стадия + ошибка
- Агрегаты: задержки connect/handshake (если измеряем)

---

### 29.7 C2 — Монитор доступности

**Назначение:** периодически пинговать HTTP или TCP и считать аптайм.

**Настройки модуля:**

- `TargetType`: HTTP / TCP
- `Target` (url или host\:port)
- `IntervalSeconds` (default 5, min 1)
- `DurationSeconds` (default 60, min 5)
- `TimeoutSeconds` (default 5)

**Сводка:**

- UptimePercent
- IncidentsCount
- AvgLatencyMs

**Детали:**

- Ошибки/инциденты: время начала/конца, причина

---

### 29.8 C3 — Security baseline (без атак)

**Назначение:** проверить наличие базовых security headers и redirect http→https (без флуда/атаки).

**Настройки модуля:**

- `Url` (обяз.)
- `Checklist` (чекбоксы):
  - HSTS (если https)
  - X-Content-Type-Options
  - X-Frame-Options
  - Content-Security-Policy
  - Referrer-Policy
  - Permissions-Policy
- `WarnOnMissing` (default ON)

**Сводка:**

- OK/WARN/FAIL counts

**Детали:**

- Таблица: HeaderName, Status (OK/WARN/FAIL), Recommendation

---

### 29.9 C4 — Preflight

**Назначение:** проверить «готовность» цели (минимум DNS/TCP/TLS/HTTP) и использовать как этап оркестратора.

**Настройки модуля:**

- `Target` (url/host)
- Флаги минимальных проверок (по умолчанию ON): dns/tcp/tls/http
- `TimeoutSeconds` (default 10)

**Сводка:**

- Ready/NotReady
- Причины (список)

**Детали:**

- По каждой проверке: OK/FAIL + сообщение

---

## 30) Секции результатов — рекомендация (как сделать красиво и полезно)

Твоя цель: **в MVP не утонуть в деталях, но дать "проверяемость" на защите.** Поэтому предлагаю фиксировать так:

1. **Сводка** — всегда видна (карточка сверху внутри «Результаты»): статус, конфиг, режим, длительность, ошибки, ключевые 3–6 метрик по модулю.
2. **Детали** — только:
   - таблица ошибок (если есть)
   - таблица агрегатов (если есть)
   - кнопка “Показать все события” (позже)
3. **Артефакты** — кнопки открытия + список.

Так ты разделяешь:

- потоковый лог (нижний drawer)
- структурированные результаты (секция «Результаты»)

---

## 31) Что нужно добавить/переделать в коде, чтобы канон стал реальностью

### 31.1 Единый объект “ModuleConfig” (на уровне UI)

Сейчас в коде есть 2 сущности на экране: “Test Library” и “Run Profile”. По твоему решению их **склеиваем**:

- UI показывает один набор кнопок Load/Save/SaveAs/Delete
- В БД храним один JSON (moduleSettings + runParameters)

**Нужно добавить:**

- DTO: `ModuleConfigPayload` (moduleKey, moduleSettings, runParameters, meta)
- Сервис: `IModuleConfigService` (List/Load/Save/SaveAs/Delete/Export/Import)
- Маппинг на существующие таблицы `TestCase/TestCaseVersion` (см. §22.1).

### 31.2 Pinned Header — 3 ряда (рефактор ModuleWorkspaceView)

- Удалить поиск модулей
- Перенести выбор модуля в горизонтальный “segmented bar”
- Перенести DisplayName/Description в 3-й ряд
- Следить, чтобы описание **не сжималось** до вертикального “столбика”

### 31.3 Placeholder overlap (“Тест” поверх введённого)

- Полностью запретить overlay-TextBlock как placeholder.
- Использовать `TextBox.Watermark`.

### 31.4 Лог Drawer: переключаемый автоскролл

Сейчас `AutoScrollBehavior` подключён статически. **Нужно:**

- `MainWindowViewModel.LogAutoScroll` (bool)
- в XAML bind `AutoScrollBehavior.IsEnabled` к `LogAutoScroll`.

### 31.5 A1 Steps UI: действие выводится автоматически

Твой UX: пользователь вводит Selector и (если нужно) Text. **Значит:**

- В UI не заставляем выбирать Action.
- В модели шага можно держать Action, но при сериализации/выполнении:
  - `Action = (Text not empty) ? Input : Click`

---

## 32) База данных (реляционная) — что выбрать и как обосновать для ВКР

### 32.1 Рекомендация: SQLite (уже в проекте)

Почему это “лучшее” для твоего случая:

- кроссплатформенность (Windows/Linux)
- 1 файл, легко переносить/архивировать
- достаточно для: конфиги, версии, профили, прогоны, run items, артефакты

### 32.2 Что именно хранить в БД (чтобы это считалось “использованием БД”)

Минимальный набор уже соответствует ВКР-логике:

- справочники: тесты/конфиги (TestCase/TestCaseVersion)
- параметры запуска (если оставим RunProfile — можно скрыть в UI, но хранить)
- факты выполнения: прогоны + детали + артефакты

### 32.3 Простейшая миграция без EF

Чтобы Codex не ломал, фиксируем правило:

- `CREATE TABLE IF NOT EXISTS ...`
- версия схемы хранится в `PRAGMA user_version`
- апгрейды делаем маленькими шагами

---

## 33) Условия для Codex (расширенная версия, чтобы не повторялись типовые ошибки)

### 33.1 Запрещено

- Любые WPF/XAML атрибуты и схемы (например, `SetterTargetType`, WPF namespace и т.п.)
- Любые биндинги без типа в местах, где Avalonia XAML-компилятор требует строгость
- Добавлять Assembly attributes вручную, если включена автогенерация

### 33.2 Обязательно при изменении XAML

- Всегда ставить `x:DataType` на корневом контроле и в `DataTemplate`.
- Если используется `ElementName=...` → обязателен `x:Name="..."`.
- Если биндимся изнутри вложенных контролов к VM — использовать `RelativeSource AncestorType=...` или `#Root`.

### 33.3 Обязательно при изменении тестов

- `WebLoadTester.Tests.csproj` должен иметь:
  - `Microsoft.NET.Test.Sdk`
  - `xunit`
  - `xunit.runner.visualstudio`
  - `coverlet.collector` (опционально)

### 33.4 Формат отчёта PR от Codex

- Summary
- Files changed
- Testing: `dotnet build`/`dotnet test` (если не может — честно написать, но код должен собираться локально)
- “Known risks” (например, XAML типизация)

---

## 34) Как сделать так, чтобы после Codex в IDE было меньше ошибок (практика)

1. **Мелкие PR вместо огромных.** 1 задача = 1 PR.
2. **После каждого PR:** `dotnet clean` → `dotnet build`.
3. Если менялся XAML:
   - чистить `bin/obj`
   - проверять, что нет `object?`-биндингов в ошибках (значит, не хватает `x:DataType`).
4. Ввести локальный скрипт `verify.ps1`:
   - restore/build/test
   - (опционально) форматирование
5. Обновлять docs и версии **в конце PR**, чтобы меньше конфликтов.

---

## 35) Вопросы (обновлённые) — требуют твоего решения

### 35.1 Обязательные решения сейчас

1. **Повтор запуска (вкладка “Прогоны”)**:

   - A) «Заполнить экран и ждать Старт»
   - B) «Сразу запускать повтор» Рекомендация: **A** (безопаснее для пользователя, меньше неожиданных запусков).

2. **Preflight статус**:

   - Рекомендация: если PreflightEnabled и NotReady → `Status = Failed`, причина в summary + RunItems.

3. **Хранение конфигов**:

   - Рекомендация: минимальный вариант §22.1 (всё в `TestCaseVersion.PayloadJson`).

4. **Строгость URL**:

   - Рекомендация: принимать абсолютные `http/https`. Если схемы нет — UI предлагает “добавить https\://” автоматически.

### 35.2 Параметры, которые лучше зафиксировать

5. Пороги warning нагрузки (Iterations/Duration/Parallelism) — подтвердить/изменить.
6. “Текст для шага Input”: пустой текст допускаем? (рекомендация: допускаем, но warning).
7. Нужно ли экспорт/импорт JSON конфигов в MVP? (рекомендация: да, но можно во второй итерации).

### 35.3 Для остальных модулей

8. Для B2 (HTTP perf): оставляем **1 endpoint** (BaseUrl+Path) в MVP или делаем список endpoints?
9. Для C2 (Monitor): достаточно HTTP GET + TCP connect или нужно оба режима в MVP?
10. Для C3 (Baseline): какие хедеры считаем FAIL, а какие WARN?

---

**Готово для следующей итерации:** после твоих ответов на §35 можно давать Codex точный промпт на рефактор UI под этот канон и на унификацию конфигов/параметров запуска.

