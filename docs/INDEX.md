# WebLoadTester — UI спецификация и полное описание ПО (единый исходный документ)

**Версия:** v3.24 17.02.2026
**Актуально для:** состояния репозитория после Prompt 6 (17.02.2026).

Этот файл — **единственный источник правды (TO‑BE)** для разработки WebLoadTester: по нему можно реализовать продукт с нуля (архитектура, данные, UI/UX, модули, запуск, отчёты, ограничения, правила). Код текущей версии считается AS‑IS и приводится к TO‑BE через раздел **«Дельта внедрения»**.

---

## 0. Инварианты продукта

### 0.1. Состав и назначение

* **10 модулей**, сгруппированы в **3 семейства** и отражены в UI как 4 вкладки верхнего уровня:

  1. **UI тестирование** (Playwright/Chromium)
  2. **HTTP тестирование**
  3. **Сеть и безопасность** (только безопасные проверки, без атак)
  4. **Прогоны** (история и артефакты)
* Продукт — **desktop MVP** (без распределённых агентов/кластера).
* UI — **на русском** (заголовки таблиц, подсказки, ошибки). Технические термины допустимы только в help/tooltip.

### 0.2. Единая модель запуска (для всех модулей)

* Запуск управляется **профилем запуска (RunProfile)**:

  * режим: **Iterations** (N итераций) или **Duration** (T секунд)
  * **Parallelism (X)** — число параллельных воркеров
  * **TimeoutSeconds** — таймаут одной итерации
  * **PauseBetweenIterationsMs** — пауза между итерациями (пейсинг)
  * флаги: HTML‑отчёт, скриншоты, Telegram
* Для UI‑модулей: `Parallelism = X` означает **X одновременных контекстов/окон**.
* **Stop ≠ Cancel**:

  * **Стоп** — мягко: завершить текущую итерацию воркера и не начинать новую.
  * **Отмена** — жёстко: немедленная отмена через `CancellationToken`.

### 0.3. Хранилище и артефакты

* Данные: **SQLite**.
* Результаты: файловая структура **`runs/{RunId}/`**.
* Отчёты: **`report.json` всегда**, `report.html` — опционально.

### 0.4. Безопасность

* Запрещены атакующие функции: скан уязвимостей, bruteforce, эксплуатация, агрессивные стресс‑атаки.

---

## 1. Технологии и зависимости

* .NET 8
* Avalonia 11 (FluentTheme), тема фиксируется в Light (`RequestedThemeVariant = Light`)
* MVVM (CommunityToolkit.Mvvm)
* Playwright for .NET (Chromium) — для UI семейства
* SQLite (Microsoft.Data.Sqlite)

**Правило проекта (фиксируем):** до завершения MVP **не добавляем новые NuGet‑зависимости**. Всё реализуем стандартными средствами .NET/Avalonia и текущими пакетами проекта.

### 1.1. Playwright/Chromium (обязательное UX‑правило)

Если Chromium не установлен — **показываем баннер** и кнопку **«Установить Chromium»** на **всех UI‑модулях**.

**Куда ставим браузеры (TO‑BE):**

* `BrowsersDirectory = {DataDirectory}/browsers` (кроссплатформенно; не требует прав на запись рядом с exe).
* Перед установкой и перед запуском Playwright приложение выставляет env:

  * `PLAYWRIGHT_BROWSERS_PATH = {DataDirectory}/browsers`

**Запуск установки из UI:**

* Кнопка **«Установить Chromium»** запускает процесс установки (PowerShell/Bash) и показывает вывод в лог‑дровере.
* Скрипты ищем относительно `AppContext.BaseDirectory`:

  * Windows: `pwsh {AppDir}/playwright.ps1 install chromium`
  * Linux: `{AppDir}/playwright.sh install chromium`

Если установка не удалась — показываем friendly‑ошибку + ссылку «Открыть лог», не блокируя остальные семейства модулей.

---

## 2. Архитектура и слои

### 2.1. Слои

* `Presentation/` — Views, ViewModels, Styles (без бизнес‑логики)
* `Modules/` — 10 модулей, каждый реализует единый контракт
* `Core/` — оркестратор, доменные сущности, отчётность, контракты
* `Infrastructure/` — SQLite, settings.json, Telegram, артефакты, Playwright factory, HTTP/network реализации

### 2.2. Контракты

**Модуль** реализует интерфейс вида `ITestModule`:

* `Id`, `DisplayName`, `Family`, `SettingsType`
* `CreateDefaultSettings()`
* `Validate(settings)`
* `ExecuteAsync(settings, RunContext ctx, CancellationToken ct)`

**Оркестратор (RunOrchestrator)** обязан:

* валидировать профиль + настройки модуля
* (опц.) выполнить Preflight
* запускать `Parallelism` воркеров по Iterations/Duration
* уважать Stop/Cancel
* собирать `RunItem` и артефакты
* сохранять итоги в SQLite + `runs/{RunId}/`

**RunContext (TO‑BE)** включает минимум:

* `RunId`
* `WorkerId`
* `Iteration`
* `RunDirectory`, `Artifacts` API
* доступ к сервисам: HTTP client factory, Playwright factory, DNS/TCP/TLS, Logger

---

## 3. Хранение: пути, settings.json, SQLite

### 3.1. Директории

По умолчанию (LocalAppData):

* `DataDirectory = .../WebLoadTester/data`
* `RunsDirectory = .../WebLoadTester/runs`
* `DatabasePath = {DataDirectory}/webloadtester.db`
* `BrowsersDirectory = {DataDirectory}/browsers`

Структура артефактов прогона (TO‑BE):

* `runs/{RunId}/report.json`
* `runs/{RunId}/report.html` (если включено)
* `runs/{RunId}/logs/run.log`
* `runs/{RunId}/screenshots/w{WorkerId}/...`
* `runs/{RunId}/profiles/w{WorkerId}/...`

### 3.2. settings.json (персистентные настройки)

Файл: `LocalAppData/WebLoadTester/settings.json`

* `DataDirectory`
* `RunsDirectory`
* `Telegram`:

  * `Enabled`
  * `BotToken`
  * `ChatId`
  * `NotifyOnStart`, `NotifyOnFinish`, `NotifyOnError`
  * `ProgressMode` (Off/EveryN/EveryTSeconds)
  * `ProgressEveryN`
  * `RateLimitSeconds`

### 3.3. SQLite (логическая схема)

Таблицы:

* **TestCases**: библиотека конфигураций
* **TestCaseVersions**: версии конфигураций (PayloadJson)
* **RunProfiles**: опциональные шаблоны профиля (можно без UI‑CRUD в MVP)
* **TestRuns**: прогоны (status, timestamps, snapshot)
* **RunItems**: элементы результатов
* **Artifacts**: реестр артефактов
* **TelegramNotifications**: журнал отправок (по желанию)

Правило: любые изменения схемы сначала фиксируются в этом документе.

---

## 4. Конфигурации (TestCase) и профиль запуска (RunProfile)

### 4.1. Что такое конфигурация

Конфигурация = (настройки модуля) + (профиль запуска).

* В БД хранится версионно: `TestCaseVersions.PayloadJson`.
* При запуске создаётся snapshot профиля в `TestRuns.ProfileSnapshotJson` и в `runs/{RunId}/report.json`.

**Важно (TO‑BE):** snapshot **настроек модуля** хранится в `runs/{RunId}/report.json` (раздел `moduleSettings`). Это нужно для «Повторить запуск» без зависимости от структуры таблиц БД.

### 4.2. Имена

* Пользователь вводит **Имя (без пробелов)** → `UserName`.
* Итоговое имя: `FinalName = UserName + "_" + ModuleSuffix` (read‑only).

### 4.3. CRUD конфигов (упрощённый и единый)

UI всегда показывает:

* ComboBox `Конфигурация`
* Кнопки: **`Загрузить` / `Сохранить` / `Удалить`**
* Поля: `Имя`, `Итоговое имя`, `Описание`

Правила:

* `Сохранить` всегда создаёт новую версию (если конфиг существует).
* `Старт` выполняет: валидировать → автосохранить → запустить.
* `Удалить` удаляет библиотеку конфигурации, **прогоны не трогаем**.

### 4.4. RunProfile (поля, флаги, дефолты)

RunProfile — единый набор параметров запуска, одинаковый для всех модулей.

#### 4.4.1. Режим нагрузки (обязательные поля)

* `Mode`: **Iterations** | **Duration**
* `Iterations` (если Iterations) > 0
* `DurationSeconds` (если Duration) > 0
* `Parallelism` 1..25 (рекомендованный soft‑warning в UI при >10)
* `TimeoutSeconds` > 0
* `PauseBetweenIterationsMs` >= 0

Рекомендуемое решение по лимиту Duration:

* поднять max с 60 до **600** секунд и показывать предупреждение при >60.

#### 4.4.2. Флаги поведения (обязательный минимум)

* `GenerateHtmlReport` (bool) — генерировать `report.html`.
* `ScreenshotPolicy` (enum):

  * `Off` — **«Выкл»**
  * `OnError` — **«При ошибке»**
  * `Always` — **«Всегда»**

**Семантика ScreenshotPolicy (TO‑BE, без усложнения UI):**

* Политика применяется **только к UI‑семейству** (`ui.scenario`, `ui.snapshot`, `ui.timing`), но хранится в общем профиле.
* `ui.snapshot`: политика **не влияет** (скриншоты — смысл модуля; всегда создаются по целям).
* `ui.scenario`:

  * `Off`: скриншоты создаются **только** шагом «Скриншот» (если такой шаг есть).
  * `OnError`: при ошибке шага/итерации делаем **аварийный скриншот** (full page) + (если возможно) скриншот проблемного селектора.
  * `Always`: в конце каждой итерации делаем **итоговый full‑page** скриншот; при ошибке — также аварийный.
* `ui.timing`:

  * `Off`: скриншоты не создаются.
  * `OnError`: аварийный full‑page при ошибке.
  * `Always`: итоговый full‑page в конце итерации.

**Именование (минимум):**

* `runs/{RunId}/screenshots/w{WorkerId}/it{Iteration}/...png`.

Примечание: политика не запрещает модулю сохранять дополнительные скриншоты по своей логике (например, шаг «Скриншот» в сценарии).

* `TelegramNotify` (bool) — включить уведомления для данного прогона (если Telegram настроен в Settings).

#### 4.4.3. Preflight перед запуском (по решению, принято)

* `PreflightEnabled` (bool) — выполнять предстартовую проверку перед основным модулем.
* `PreflightConfigId` (nullable) — ссылка на конфигурацию модуля `net.preflight`.

UX‑правило:

* Если `PreflightEnabled=true` и `Preflight` завершился FAIL — основной модуль **не запускается**, прогон получает статус `Failed` и в `report.json` фиксируется причина.
* По умолчанию `PreflightEnabled=false` (чтобы не усложнять MVP).

---

## 5. Оркестратор: точная семантика запуска

### 5.1. Порядок операций (обязательный)

1. Validate RunProfile
2. Validate module settings
3. Save config version (если требуется автосейв)
4. Create TestRun(Status=Running)
5. Prepare run folder (`runs/{RunId}`)
6. Preflight (опционально по флагу)
7. Execute: воркеры + сбор результатов
8. Save `RunItems`, `Artifacts`, `report.json` (+ `report.html`)
9. Finalize status + timestamps

### 5.2. Воркеры

* Запускаем `Parallelism` воркеров: `WorkerId = 1..X`.
* Итерации:

  * Iterations: распределяем N по воркерам (round‑robin или через общий счётчик).
  * Duration: выполняем итерации до дедлайна.
* Между итерациями: `Delay(PauseBetweenIterationsMs)`.

**Семантика «итерации» для модулей со списками (TO‑BE):**

* Для модулей, где есть список элементов (цели/endpoints/assets/порты), **1 итерация = один полный проход по всему списку** внутри воркера.
* На каждый элемент списка создаётся отдельный `RunItem` (с `workerId`, `iteration`, `itemIndex`, `name`).
* Это делает результаты детерминированными и упрощает агрегаты (особенно для Duration‑режима).
* Каждая итерация ограничена `TimeoutSeconds`.

### 5.3. Статусы

Рекомендуемые статусы прогона:

* `Running`
* `Success`
* `Failed`
* `Canceled`
* `Stopped` (мягкая остановка)

Правила итогового статуса:

* если была отмена → `Canceled`
* если был Stop → `Stopped` (если не было Failure)
* если есть хотя бы один Failure (и не Cancel) → `Failed`
* иначе → `Success`

---

## 6. UI/UX канон

### 6.1. Главное окно (элементы управления и взаимодействие)

#### 6.1.1. Верхняя статус‑панель (глобальная)

Назначение: мгновенно показывать «готовность окружения» и давать быстрые переходы.

Элементы:

* **Индикатор БД**: `OK/Ошибка`.

  * Клик → открыть **Настройки** на разделе «Пути/База».
  * Tooltip: путь к БД и краткая ошибка (если есть).
* **Индикатор Telegram**: `Выкл/Ок/Ошибка`.

  * Клик → открыть **Настройки** на разделе Telegram.
  * Tooltip: ChatId, включённость, последняя ошибка.
* **Индикатор Playwright/Chromium**: `Не установлен/Ок`.

  * Клик → если не установлен, открывает модальное окно установки (см. §1.1) / если установлен — показывает путь.
* **Кнопка «Настройки»** (шестерёнка) — открывает `SettingsWindow`.
* (Опционально) **Версия приложения** в правой части (read‑only).

#### 6.1.2. Вкладки верхнего уровня

* UI тестирование
* HTTP тестирование
* Сеть и безопасность
* Прогоны

Правило UX: вкладки всегда доступны, но внутри вкладки модульные элементы могут быть disabled, если не выполнены preconditions (например, Chromium не установлен).

#### 6.1.3. Лог‑дровер (Expander) / панель сообщений

Назначение: понятный «живой» статус без перегрузки UI.

Элементы:

* Список последних ~500 сообщений (виртуализация/ограничение).
* Переключатель **«Автопрокрутка»**.
* Кнопка **«Копировать»** (в буфер).
* Кнопка **«Очистить»**.
* (Опционально) Фильтр уровня: Info/Warning/Error.

Поведение:

* Во время прогона лог отображает прогресс (старт/стоп, worker‑events, ключевые ошибки).
* Ошибка в модуле должна сопровождаться friendly‑текстом + ссылкой «Открыть report.json» после завершения.

### 6.2. ModuleWorkspace (унифицированная компоновка и взаимодействие)

На каждой вкладке‑модуле одинаковый каркас:

1. **Карточка «Конфигурация»** (CRUD)
2. **Карточка «Настройки модуля»**
3. **Карточка «Профиль запуска»**
4. **Панель запуска**: Старт / Стоп / Отмена + прогресс + кнопки артефактов

Общие правила UI (анти‑наложения, MVP):

* Вкладка строится как `Grid`: верх — карточки/тулбары (`Auto`), центр — контент (`*`), низ — панель запуска (`Auto`).
* **Без вложенных ScrollViewer.** Если нужна прокрутка — один вертикальный `ScrollViewer` только для формы модуля. `DataGrid/ListBox` прокручиваются сами.
* Базовый паттерн полей — **FieldBlock** (современный и устойчивый к маленькому окну):

  * `Label` сверху (wrap разрешён),
  * `Control` снизу (Stretch),
  * `Hint/Error` ниже.
    Это исключает накладывание лейблов на контролы при узкой ширине.
* Для плотных таблиц/рядов допускается **FieldRowDense** (лейбл слева), но только если:

  * label‑колонка фиксирована (`MinWidth=180`, `MaxWidth=240`),
  * лейбл всегда `TextWrapping=Wrap`,
  * control всегда в отдельной колонке (`Grid.Column=1`, `HorizontalAlignment=Stretch`).
* Любая обязательность поля обозначается `*` и подсказкой (tooltip).

#### 6.2.1. Карточка «Конфигурация» (CRUD)

Элементы:

* ComboBox **«Конфигурация»** (список сохранённых конфигов для данного модуля).
* Кнопки: **«Загрузить» / «Сохранить» / «Удалить»**.
* Поля:

  * **«Имя»*** (без пробелов; допускаются латиница/цифры/`-`/`_`).
  * «Итоговое имя» (read‑only: `UserName + _ + ModuleSuffix`).
  * «Описание» (опционально).
* Индикатор состояния: `Сохранено` / `Есть несохранённые изменения`.

Поведение:

* **Загрузить**: подтягивает последнюю версию выбранной конфигурации и заполняет «Настройки модуля» + «Профиль запуска».
* **Сохранить**: создаёт новую версию конфигурации (versioned save). Если имя новое — создаёт конфигурацию.
* **Удалить**: удаляет библиотеку конфигурации (версии тоже). Прогоны не удаляются.
* При попытке сменить конфигурацию при несохранённых изменениях — диалог: «Сохранить изменения?» (Сохранить / Не сохранять / Отмена).

Ошибки валидации:

* При пустом имени или недопустимых символах кнопки **Старт** и **Сохранить** disabled, под полем показывается причина.

#### 6.2.2. Карточка «Настройки модуля»

* Содержит только поля конкретного модуля (см. §8).
* Валидация обязательных полей показывает inline‑ошибки.

#### 6.2.3. Карточка «Профиль запуска»

Элементы:

* Переключатель режима: **Iterations / Duration**.
* Поля: `Iterations` или `DurationSeconds`, `Parallelism`, `TimeoutSeconds`, `PauseBetweenIterationsMs`.
* Группа «Вывод/уведомления»:

  * `GenerateHtmlReport`
  * `ScreenshotPolicy` (Выкл/При ошибке/Всегда)
  * `TelegramNotify`
* Группа «Preflight»:

  * `PreflightEnabled`
  * `PreflightConfigId` (выбор конфигурации preflight) — показывать только если включено.

Поведение:

* Невалидные значения подсвечиваются, **Старт** disabled.
* При `DurationSeconds>60` — предупреждение (но запуск разрешён).

#### 6.2.4. Панель запуска (Run panel)

Элементы:

* Кнопки:

  * **«Старт»** — запускает оркестратор.
  * **«Стоп»** — soft stop.
  * **«Отмена»** — hard cancel.
* Индикатор состояния: `Готово / Выполняется / Остановлено / Отменено / Ошибка`.
* Прогресс:

  * progress bar
  * счётчики: `Worker X/Y`, `Итерация N`, `Ошибок K` (минимум)
* Кнопки артефактов (активируются после запуска):

  * **«Открыть папку прогона»**
  * **«Открыть report.json»**
  * **«Открыть report.html»** (только если сгенерирован)

Поведение:

* При старте: создаётся `RunId`, отображается пользователю.
* Кнопки **Стоп/Отмена** активны только во время прогона.
* По завершении: показывать краткий итог (Success/Failed + длительность + число ошибок).

#### 6.2.5. Единая панель управления таблицами (TableToolbar)

Назначение: унифицировать UX редактирования строк, сохранив уникальность полей модулей.

**Визуально (важно для маленького окна):**

* TableToolbar — это строка кнопок, которая **умеет переноситься** на 2‑ю строку при узкой ширине.
* Реализация: `WrapPanel` + класс `wrap-gap`.

  * В Avalonia 11 у `WrapPanel` **нет** свойства `Spacing` (исторически давало AVLN2000), поэтому расстояния задаём **стилем** через `Margin` на дочерних элементах.
  * Канонично: `WrapPanel` получает `Classes="wrap-gap"`, а стиль вида `WrapPanel.wrap-gap > Button`/`WrapPanel.wrap-gap > *` задаёт `Margin="0,0,8,8"` (или эквивалент).

Элементы (слева направо):

* **«Добавить»** — добавляет новую строку в конец и переводит фокус в первую обязательную ячейку.
* **«Удалить»** — удаляет выбранные строки (с подтверждением при удалении >1 строки).
* **«Дублировать»** — копирует выбранную строку/строки.
* **«Вверх / Вниз»** *(опционально)* — показывается только если порядок строк влияет на выполнение/смысл.
* **«Очистить»** *(опционально)* — удалить все строки (с подтверждением).

Клавиатура:

* `Enter` — добавляет строку (если фокус в последней строке) или переходит к следующей ячейке.
* `Del` — удалить выбранную строку/строки.
* `Ctrl+C / Ctrl+V` — копировать/вставить строки (TSV/CSV).

Валидация:

* обязательные колонки подсвечиваются на уровне строки (рамка + причина).
* если таблица содержит ошибки — **Старт disabled** и показывается агрегированное сообщение.

Матрица применения (TO‑BE):

* `ui.scenario` (Шаги): Add/Delete/Duplicate/**Up/Down** (+ Clear опц.)
* `ui.snapshot` (Цели): Add/Delete/Duplicate (Up/Down скрыты)
* `ui.timing` (Цели): Add/Delete/Duplicate (Up/Down скрыты)
* `http.functional` (Endpoints): Add/Delete/Duplicate (Up/Down скрыты)
* `http.performance` (Endpoints): Add/Delete/Duplicate (Up/Down скрыты)
* `http.assets` (Assets): Add/Delete/Duplicate (Up/Down скрыты)
* `net.diagnostics` (Ports, если есть список): Add/Delete (Duplicate опц., Up/Down скрыты)

### 6.3. SettingsWindow (настройки приложения и взаимодействие)

Цель: хранить **глобальные** настройки (пути, Telegram), которые не относятся к конкретной конфигурации теста.

#### 6.3.1. Раздел «Пути»

Элементы:

* `DataDirectory` (папка данных) + кнопка **«Выбрать…»**
* `RunsDirectory` (папка прогонов) + кнопка **«Выбрать…»**
* `DatabasePath` (read‑only или вычисляемый) + кнопка **«Открыть папку БД»**

Поведение:

* При изменении `RunsDirectory`/`DataDirectory` — предупреждение о переносе данных (в MVP перенос не обязателен; достаточно изменить путь на будущие записи).
* Валидация: путь должен существовать или быть создаваемым; ошибки показывать inline.

#### 6.3.2. Раздел «Telegram»

Элементы:

* Toggle **«Включить Telegram»**
* `BotToken` (секрет; отображать как password)
* `ChatId`
* Checkboxes: `NotifyOnStart`, `NotifyOnFinish`, `NotifyOnError`
* Progress:

  * `ProgressMode` (Off/EveryN/EveryTSeconds)
  * `ProgressEveryN`
  * `RateLimitSeconds`
* Кнопка **«Тестовое сообщение»**

Поведение:

* Нажатие «Тестовое сообщение» отправляет короткий текст и показывает результат (успешно/ошибка).
* Ошибка Telegram не должна ломать запуск тестов: фиксируется в логе/отчёте, но статус прогона определяется результатами теста.

### 6.4. Вкладка «Прогоны» (история, артефакты, повтор запуска)

Цель: быстро находить прогоны, открывать артефакты, повторять запуск и удалять ненужное.

#### 6.4.0. Основные элементы

1. **Панель фильтров** (сверху)
2. **Таблица прогонов** (центр)
3. **Панель деталей прогона** (справа или снизу, в зависимости от ширины окна)
4. **Панель действий** (кнопки над таблицей и/или контекстное меню строки)

#### 6.4.1. Таблица прогонов

Рекомендуемые колонки (минимум MVP):

* `Дата/время` (StartedAtLocal)
* `Статус` (Running/Success/Failed/Stopped/Canceled)
* `Модуль`
* `Имя` (FinalName)
* `Длительность` (Duration)
* `Ошибок` (Failures)
* `Parallelism`
* `Режим` (Iterations/Duration)

Поведение:

* Сортировка по клику на заголовок колонки (по умолчанию — по `Дата/время` desc).
* Выбор строки обновляет панель деталей.
* Двойной клик по строке: **открыть report.json** выбранного прогона (быстрое действие). Панель деталей обновляется одиночным кликом по строке.

#### 6.4.2. Панель фильтров

Элементы:

* Строка поиска: ищет по `FinalName`, `moduleId`, `RunId`.
* Фильтр `Модуль` (All + 10 модулей).
* Фильтр `Статус` (All/Success/Failed/Stopped/Canceled/Running).
* Фильтр `Период` (Сегодня / 7 дней / 30 дней / Все).
* Toggle **«Только с ошибками»** (Failures>0).

UX‑правило:

* Фильтры не должны блокировать UI. Применение — мгновенное, с debounce для строки поиска.

#### 6.4.3. Панель действий

Кнопки над таблицей (основные):

* **«Открыть папку»**
* **«Открыть report.json»**
* **«Открыть report.html»** (если есть)
* **«Повторить запуск»**
* **«Удалить прогон»**
* **«Копировать RunId»**

Контекстное меню строки дублирует эти действия.

#### 6.4.4. Панель деталей прогона

Содержимое (MVP):

* Заголовок: `FinalName` + `RunId` (кнопка копировать)
* Краткое резюме: статус, длительность, модуль, profile snapshot (режим, parallelism, timeout, pause)
* Список артефактов с кнопками открыть (json/html/папка/скриншоты)
* Сводка ошибок: топ‑3 причин (по message) + счётчики
* (Опционально) Мини‑таблица `RunItems` (первые 20 строк) с кнопкой «Открыть report.json» для полного просмотра

#### 6.4.5. Действие «Повторить запуск» (точная семантика)

Назначение: быстро восстановить настройки, с которыми выполнялся выбранный прогон, чтобы пользователь мог **перезапустить** тест.

Поведение (TO‑BE):

1. Пользователь выбирает строку прогона в таблице и нажимает кнопку/контекстное меню **«Повторить запуск»**.
2. Приложение:

   * читает данные прогона **в первую очередь** из `runs/{RunId}/report.json` (если файл существует),
   * извлекает `moduleId`, `profile` (RunProfile snapshot) и `moduleSettings` (snapshot настроек модуля),
   * **переключает UI** на соответствующую вкладку модуля,
   * заполняет поля **«Настройки модуля»** и **«Профиль запуска»** значениями из snapshot,
   * в карточке «Конфигурация» устанавливает режим **«Загружено из прогона {RunId}»** и показывает информационный бейдж.

Если `report.json` отсутствует, используем fallback:

* читаем минимальный snapshot профиля из БД (`TestRuns.ProfileSnapshotJson`) и предлагаем открыть папку/JSON для полного восстановления.

3. Важное правило: **автозапуск не выполняется**. Пользователь вручную нажимает **«Старт»** после проверки/правок.

Ошибки/edge cases:

* Если модуль отсутствует/переименован → показать диалог: «Невозможно повторить: модуль не найден», предложить открыть папку прогона.
* Если snapshot повреждён → показать диалог и предложить открыть `report.json`.

Результат для пользователя:

* он получает полностью заполненную форму модуля, готовую к повторному запуску одним нажатием «Старт».

#### 6.4.6. Действие «Удалить прогон»

Поведение:

* Подтверждение (диалог): «Удалить прогон {RunId}? Будут удалены запись из БД и папка runs/{RunId}.»
* При успехе: строка исчезает из таблицы, детали очищаются.
* При ошибке удаления файлов: показать диалог, предложить открыть папку и удалить вручную.

### 6.5. Валидация, сообщения и блокировка действий (единый стандарт)

#### 6.5.1. Когда показываем ошибки

* Inline‑валидация показывается после `LostFocus` и при попытке **Старт/Сохранить**.
* При **Старт** показываем все ошибки одновременно и скроллим к первой ошибке.

#### 6.5.2. Где показываем ошибки

* Под полем/таблицей: короткое сообщение причины.
* Сверху карточки: компактный warning‑banner, если ошибок несколько.
* В лог‑дровере: одно агрегированное сообщение (без спама).

#### 6.5.3. Блокировки

* **Старт disabled**, если:

  * невалиден RunProfile,
  * невалидны настройки модуля,
  * невалидны таблицы (шаги/цели/endpoints/assets).
* **Сохранить disabled**, если имя конфигурации невалидно.

#### 6.5.4. UX‑принципы

* Ошибки формулируются по‑человечески: «Укажите URL», «Добавьте хотя бы один endpoint», «В шаге 3 не задан селектор».
* Поля обязательности помечаются `*`.
* Длинные тексты не должны ломать верстку:

  * для ячеек таблиц и выпадающих списков: `TextTrimming=CharacterEllipsis` + tooltip с полным текстом,
  * для лейблов полей: `TextWrapping=Wrap`,
  * для кнопок: **без переносов текста**, вместо этого используем перенос кнопок на 2‑ю строку через WrapPanel.

### 6.6. UI Layout Blueprint (презентабельность + отсутствие наложений)

Этот раздел фиксирует **геометрию и компоновку** так, чтобы при маленьком окне элементы **не накладывались** и всегда оставались доступными.

#### 6.6.1. Окно и размеры

* Главное окно **ресайзабельное**.
* Рекомендуемый стартовый размер: `1200x800`.
* Минимальный размер (MVP‑гарантия вёрстки): `MinWidth=1024`, `MinHeight=720`.
* На меньших размерах допускается вертикальный скролл, но **наложений быть не должно**.

#### 6.6.2. Единые токены отступов/размеров (MVP)

* `PagePadding = 16`
* `CardPadding = 16`
* `CardSpacing = 12` (между карточками)
* `FieldSpacing = 8` (внутри карточки)
* `ButtonMinWidth = 120`, `ButtonHeight = 32`
* `NumericBoxWidth = 140` (Iterations/Duration/Timeout/Parallelism/Pause)
* `LabelFontSize = 12`, `ControlFontSize = 12` (единый)

#### 6.6.3. Компоновка ModuleWorkspace (все модули)

Структура вкладки модуля:

* `Grid` Rows: `Auto` (баннеры/ошибки), `*` (форма), `Auto` (RunPanel).
* Форма (`*`) — `ScrollViewer` → `StackPanel` с карточками:

  1. Конфигурация
  2. Настройки модуля
  3. Профиль запуска

**Ограничение ширины формы (презентабельность):**

* Контент формы центрируется и ограничивается `MaxWidth=1100` (на широких мониторах форма не «растекается»).

#### 6.6.4. Карточки и поля

* Карточка = `Border`/`Panel` с `Padding=CardPadding` и `Margin` снизу `CardSpacing`.
* Поля в карточке — **FieldBlock** (лейбл сверху, контрол снизу).
* Для числовых параметров (Iterations/Duration/Parallelism/Timeout/Pause):

  * используем компактные `NumericUpDown`/`TextBox` фиксированной ширины `NumericBoxWidth`.
  * группируем в `Grid` 2 колонки, чтобы экономить высоту, но без риска наложения.

#### 6.6.5. Кнопочные панели (чтобы ничего не уезжало за границы)

* Любая «строка кнопок» (CRUD, RunPanel actions, TableToolbar) делается через `WrapPanel`.
* Расстояния между кнопками задаём **не свойствами WrapPanel**, а **классом** `wrap-gap` (см. §6.2.5), чтобы не ловить AVLN/MC ошибки.
* Кнопки имеют `MinWidth=ButtonMinWidth`, `Height=ButtonHeight`, текст **не переносится**.
* На узкой ширине кнопки автоматически уходят на следующую строку вместо наложений/обрезания.

#### 6.6.6. Таблицы (DataGrid) — чтобы не было наложений и всё читалось

* Таблица имеет `MinHeight=220` и по возможности размещается в контейнере `*`, чтобы прокрутка была внутри DataGrid.
* Включаем горизонтальный скролл: `HorizontalScrollBarVisibility=Auto`.
* Длинные значения в ячейках: `TextTrimming=CharacterEllipsis` + tooltip.
* Колонки по умолчанию:

  * статусы/числа — узкие (`Width=Auto`),
  * имя/URL — `Width=*`.

#### 6.6.7. Вкладка «Прогоны» — стабильная компоновка без адаптивных «ломаний»

Чтобы не зависеть от ширины окна и не получать наложения:

* «Прогоны» строим как вертикальный сплит:

  * сверху: фильтры (Auto)
  * центр: `Grid` Rows `*` (таблица) + `*` (детали) с `GridSplitter` между ними.
* Детали можно свернуть (Expander «Детали»), чтобы на маленькой высоте оставить максимум места таблице.

#### 6.6.8. Гарантия отсутствия наложений (UI‑smoke чеклист)

Перед принятием изменений UI считаем задачу выполненной только если:

* при размере окна `1024x720`:

  * ни один `TextBlock` не перекрывает контрол,
  * кнопки не уходят за границы (переносятся на 2‑ю строку),
  * все вкладки открываются без «обрезанных» секций (доступен вертикальный скролл),
  * таблицы прокручиваются и не вываливаются из контейнера,
  * длинные строки не ломают layout (ellipsis + tooltip).

---

## 7. Каталог модулей (10)

| Id               | UI‑имя                     | Семейство | Назначение                    |
| ---------------- | -------------------------- | --------- | ----------------------------- |
| ui.scenario      | A1 UI сценарий             | UI        | шаги в браузере               |
| ui.snapshot      | A2 UI снимки               | UI        | скриншоты URL/элементов       |
| ui.timing        | A3 UI тайминги             | UI        | метрики загрузки              |
| http.functional  | B1 HTTP функциональные     | HTTP      | проверки условий              |
| http.performance | B2 HTTP производительность | HTTP      | агрегаты latency/ошибок       |
| http.assets      | B3 HTTP ассеты             | HTTP      | проверка статических ресурсов |
| net.diagnostics  | C1 DNS/TCP/TLS             | NetSec    | безопасная диагностика        |
| net.availability | C2 Доступность             | NetSec    | атомарная проверка            |
| net.security     | C3 Security baseline       | NetSec    | заголовки/redirect            |
| net.preflight    | C4 Preflight               | NetSec    | быстрый предстартовый чек     |

---

## 8. Модули: действия пользователя, обязательные поля, результат

Ниже описано, что пользователь делает в UI, какие поля обязательны и какие артефакты получает.

### 8.0. Общие правила для списков/таблиц в модулях

Если модуль содержит таблицу (шаги/цели/endpoints/assets/порты), управление строками выполняется через **TableToolbar** (§6.2.5).

Общее правило обязательности:

* если таблица должна содержать минимум 1 строку — это явно написано в UI и валидация блокирует запуск.

### 8.A. UI тестирование (Playwright)

#### A1. ui.scenario — UI сценарий

Пользователь:

1. (Опционально) выбирает конфигурацию → **Загрузить**.
2. Заполняет (минимум):

   * `Стартовый URL`* (обязателен, если первый шаг не «Переход»)
   * `Таймаут ожиданий, мс`* > 0
   * таблицу `Шаги`* (минимум 1 строка)
3. Настраивает профиль запуска:

   * `Parallelism = X` (число окон/контекстов)
   * режим Iterations или Duration
   * `PauseBetweenIterationsMs` для периодических прогонов/снимков «каждые N минут»
   * `ScreenshotPolicy` (Выкл/При ошибке/Всегда)
4. Нажимает **Старт**.

Таблица `Шаги` (Variant B): `Действие + Селектор + Значение + Задержка, мс`.

* Переход: `Значение` = URL (обязательно)
* Ожидание элемента: `Селектор` (обязательно)
* Клик: `Селектор` (обязательно)
* Ввод текста: `Селектор` + `Значение` (обязательно)
* Проверка текста: `Селектор` + `Значение` (обязательно)
* Скриншот: `Селектор` опционально
* Пауза: `Задержка, мс` (обязательно, >0)

Управление таблицей «Шаги»:

* Кнопки: **Добавить / Удалить / Дублировать / Вверх / Вниз** (+ «Очистить» опц.).
* Порядок строк **критичен**: выполнение строго сверху вниз.
* При ошибках строк **Старт disabled** и сообщение: «Исправьте ошибки в шагах».

Результат:

* `report.json` (+ `report.html` если включено)
* `runs/{RunId}/screenshots/w{WorkerId}/...` (по политике)
* `runs/{RunId}/logs/run.log`
* RunItems: минимум 1 на сценарий (воркер/итерация), шаги — либо отдельными RunItems (тип Step), либо в `extraJson.steps[]` (см. §8.0 и §9.1).

#### A2. ui.snapshot — UI снимки

Назначение: делать снимки страниц/элементов (не сценарий).

Пользователь:

1. Заполняет таблицу `Цели`* (минимум 1):

   * `URL`* (обязательно)
   * `Селектор` (опционально; если задан — делаем снимок элемента)
   * `Имя` (опционально; используется в имени файла/отчёте)
2. Выбирает параметры ожидания:

   * `WaitUntil` (Load/DOMContentLoaded/NetworkIdle)
   * `TimeoutSeconds`* > 0
   * `FullPage` (toggle)
   * `ViewportWidth/ViewportHeight` (оба заданы или оба пустые)
3. Настраивает профиль запуска (Parallelism, Iterations/Duration, PauseBetweenIterationsMs).
4. Нажимает **Старт**.

Управление таблицей «Цели»:

* Кнопки: **Добавить / Удалить / Дублировать** (Вверх/Вниз скрыты).
* Порядок не влияет на смысл; выполнение идёт по текущему порядку строк для детерминированной нумерации файлов.

Результат:

* скриншоты по целям (папка `screenshots/w{WorkerId}`)
* `report.json` (+ `report.html` опц.)
* RunItems по целям

#### A3. ui.timing — UI тайминги

Назначение: измерение времени загрузки/метрик браузера.

Пользователь:

1. Заполняет таблицу `Цели`* (минимум 1): `URL`* (+ `Имя` опц.)
2. Выбирает `WaitUntil`, `TimeoutSeconds`*.
3. Настраивает профиль запуска.
4. Нажимает **Старт**.

Управление таблицей «Цели»:

* Кнопки: **Добавить / Удалить / Дублировать** (Вверх/Вниз скрыты).

Результат:

* RunItems с timing‑метриками (TTFB/DOMLoad/Load, по поддерживаемым данным Playwright)

### 8.B. HTTP тестирование

#### B1. http.functional — HTTP функциональные

Назначение: проверка ответов по endpoints (assert’ы) без тяжёлой нагрузочной части.

Пользователь:

1. Заполняет:

   * `BaseUrl`* (обязательно)
   * `TimeoutSeconds`* > 0
2. Добавляет минимум 1 endpoint в список `Endpoints`*:

   * `Имя`* (уникально в конфиге)
   * `Метод`* (GET/POST/PUT/PATCH/DELETE…)
   * `Путь`* (например `/api/v1/users`)
3. В панели деталей выбранного endpoint настраивает проверки:

   * `ExpectedStatusCode`* (обязательно, например 200)
   * опционально (MVP):

     * `MaxLatencyMs`
     * `RequiredHeaders` (список «ключ:значение» или только ключ — формат фиксируем в UI подсказкой)
     * `BodyContains` (простое подстрочное вхождение)
     * `JsonFieldEquals` (пары `path=value`, где `path` — **dot‑path** вида `a.b.c` и допускает индексы массивов в одном из двух простых форматов: `items[0].id` или `items.0.id` — принимаем любой, который уже реализован в коде; в UI дать подсказку)
4. Нажимает **Старт**.

Управление списком Endpoints (List+Details):

* Левая панель: список endpoint’ов.
* Кнопки над списком: **Добавить / Удалить / Дублировать**.
* Порядок не важен.

Валидация:

* если endpoints = 0 → Старт disabled («Добавьте хотя бы один endpoint»)
* если у endpoint нет метода/пути/expected status → Старт disabled
* если `Имя` не уникально → Старт disabled

Результат:

* RunItems по endpoints (kind=`Endpoint`): `statusCode`, `latencyMs`, признак ok, нарушенные условия (message/errorKind + детали в metrics/extra)

#### B2. http.performance — HTTP производительность

Назначение: измерение latency/ошибок по endpoints в режиме Iterations/Duration с Parallelism.

Пользователь:

1. Заполняет `BaseUrl`*, `TimeoutSeconds`*.
2. Добавляет endpoints* (как в B1). Поле `ExpectedStatusCode` **не обязательно**, но если задано — используется как проверка.
3. Настраивает профиль запуска (`Parallelism` + Iterations/Duration + `PauseBetweenIterationsMs`).
4. Нажимает **Старт**.

Результат:

* RunItems по endpoints (kind=`Endpoint`) с `latencyMs`, `statusCode`, ok.
* Summary агрегаты (минимум): `total`, `failed`, `avgLatencyMs`, `maxLatencyMs` (общие; при наличии — и по endpoint’ам).

#### B3. http.assets — HTTP ассеты

Назначение: проверка статических ресурсов (css/js/img) по URL.

Пользователь:

1. Заполняет таблицу `Assets`* (минимум 1):

   * `URL`* (обязательно)
   * `Имя` (опционально, но рекомендуется — используется в отчёте/файлах)
   * `ExpectedContentType` (опц.)
   * `MaxLatencyMs` (опц.)
   * `MaxSizeKb` (опц.)
2. Настраивает профиль запуска.
3. Нажимает **Старт**.

Управление таблицей «Assets»:

* Кнопки: **Добавить / Удалить / Дублировать** (Вверх/Вниз скрыты).

Результат:

* RunItems по assets (kind=`Asset`) с метриками: `statusCode`, `latencyMs`, `bytes`, `contentType`, ok.

### 8.C. Сеть и безопасность (без атак)

#### C1. net.diagnostics — DNS/TCP/TLS

Назначение: безопасная диагностика домена/хоста: резолв DNS, TCP connect, TLS handshake.

Пользователь:

1. Заполняет `Hostname`*.
2. Выбирает:

   * `UseAutoPorts` (по схеме) или ручные `Ports`.
   * toggles: `CheckDns`, `CheckTcp`, `CheckTls`.
3. Если `UseAutoPorts=false`: заполняет таблицу `Ports`* (минимум 1): `Port`* (1..65535), `Protocol` (Tcp по умолчанию).
4. Настраивает профиль запуска (обычно Iterations=1, Parallelism=1).
5. Нажимает **Старт**.

Управление таблицей `Ports` (только в ручном режиме):

* Кнопки: **Добавить / Удалить** (Дублировать опц.).

Результат:

* RunItems DNS/TCP/TLS с деталями (IP, ошибки, коды TLS, времена)

#### C2. net.availability — Доступность

Назначение: атомарная проверка доступности цели (HTTP или TCP) в цикле через RunProfile.

Пользователь:

1. Выбирает `CheckType`: **HTTP** или **TCP**.
2. Заполняет цель*:

   * для HTTP: `Url`* (полный URL)
   * для TCP: `Host`* и `Port`* (или `host:port` в одном поле)
3. Заполняет `TimeoutMs`* > 0.
4. Настраивает профиль запуска:

   * Для периодической проверки: `Mode=Duration`, `PauseBetweenIterationsMs` = интервал.
   * `Parallelism` обычно 1 (но допускается >1 для параллельной проверки нескольких целей — если добавим таблицу целей, см. ниже).
5. Нажимает **Старт**.

Рекомендация по UX (MVP):

* В MVP цель **одна** (форма), без таблицы целей.
* Если позже понадобится много целей — добавим таблицу `Targets` и применим TableToolbar.

Результат:

* RunItems по каждой итерации проверки (timestamp, ok/fail, latency)

#### C3. net.security — Security baseline

Назначение: безопасная проверка «гигиены» HTTP(S) без эксплуатации.

Пользователь:

1. Заполняет `Url`*.
2. Выбирает чекбоксы проверок (можно «Выбрать рекомендуемые»):

   * `CheckHttpsRedirect` (http→https, если применимо)
   * `CheckHsts` (только https)
   * `CheckXContentTypeOptions`
   * `CheckFrameProtection` (X‑Frame‑Options или CSP frame‑ancestors)
   * `CheckReferrerPolicy`
   * `CheckCspPresent` (наличие CSP без глубокой валидации)
   * `CheckCookiesFlags` (Secure/HttpOnly/SameSite при Set‑Cookie)
3. Нажимает **Старт**.

Результат:

* RunItems по каждой проверке + понятные пояснения (что не так и почему важно)

Семантика итогов (TO‑BE):

* Каждая проверка возвращает `severity`: `Pass/Warn/Fail/NA`.
* Итог модуля:

  * `Failed`, если есть хотя бы один `Fail` (и не было Cancel).
  * `Success`, если только `Pass/Warn/NA`.

Рекомендованные правила severity (MVP):

* `Fail`: нет ответа/нет TLS при https/timeout/невозможно выполнить базовый запрос.
* `Warn`: отсутствуют рекомендованные security‑headers (HSTS, X‑Content‑Type‑Options, Referrer‑Policy, Frame protection, CSP present, cookie flags).
* `NA`: проверка не применима (например HSTS для http).

#### C4. net.preflight — Preflight

Назначение: быстрый предстартовый чек окружения перед любым запуском.

Пользователь (как отдельный модуль):

1. Заполняет `Target` (опционально: Url/Hostname).
2. Выбирает набор проверок (чекбоксы): `DNS`, `TCP`, `TLS`, `HTTP`.
3. Нажимает **Старт**.

Пользователь (как стадия перед запуском другого модуля):

* В профиле запуска включает `PreflightEnabled` и выбирает `PreflightConfigId`.

Маппинг цели, если в конфиге preflight Target не задан (TO‑BE):

* UI модули: берём `Стартовый URL` (ui.scenario) или первый `URL` из целей (ui.snapshot/ui.timing).
* HTTP модули: берём `BaseUrl`.
* NetSec модули: берём их целевое поле (`Hostname`/`Url`/`Host:Port`).

Далее preflight извлекает `hostname` (и при необходимости `port` по схеме) и выполняет выбранные чекбоксы.

Поведение:

* Preflight выполняется первым.
* При FAIL: основной модуль **не запускается**, прогон получает статус `Failed`, в `report.json` фиксируется причина.

## 9. Отчётность

### 9.1. report.json (обязательный контракт)

Цель: один файл, который позволяет **(а)** показать результат, **(б)** повторить запуск, **(в)** восстановить контекст ошибок.

#### 9.1.1. Минимальная структура (TO‑BE)

* `runId`, `moduleId`, `finalName`
* `startedAtUtc`, `finishedAtUtc`, `status`
* `profile`: snapshot RunProfile (как запускали)
* `moduleSettings`: snapshot настроек конкретного модуля (как тестировали)
* `summary`:

  * `durationMs`
  * `totalItems`, `failedItems`
  * `workers`
* `items[]`: массив результатов (соответствует RunItems)
* `artifacts[]`: пути/типы (соответствует Artifacts)

#### 9.1.2. Контракт RunItem (минимум)

Каждый `items[]` должен содержать:

* `kind` (enum): `Scenario` | `Step` | `Target` | `Endpoint` | `Asset` | `Check` | `PreflightCheck`
* `workerId` (int)
* `iteration` (int)
* `itemIndex` (int, опционально) — индекс в списке целей/endpoints/assets
* `name` (string) — человекочитаемое имя (шаг/цель/endpoint/проверка)
* `ok` (bool)
* `severity` (enum, опц.): `Pass` | `Warn` | `Fail` | `NA` (для baseline‑проверок)
* `startedAtUtc`, `finishedAtUtc`, `durationMs`
* `message` (опц.) — дружелюбное объяснение
* `errorKind` (опц.) — тип ошибки (Timeout/AssertFailed/Exception/Network…)
* `metrics` (object, опц.) — latencyMs, statusCode, timing и т.д.
* `artifactRefs[]` (опц.) — ссылки на артефакты (скриншоты, логи)

#### 9.1.3. Правила

* `report.json` пишется даже при Failed/Canceled/Stopped.
* `moduleSettings` и `profile` обязательны: именно они нужны для «Повторить запуск».
* `items[].workerId` и `items[].iteration` — каноничные поля. Дублировать их в `extraJson` не требуется (допускается только для совместимости/экспериментов).
* В `items[].metrics` допускается произвольная структура, но базовые ключи должны быть единообразны (latencyMs/statusCode/bytes/timing...).
* В `items[].extraJson` допускается произвольная структура для редких расширений, но без «критичных» данных, необходимых для повторного запуска.

### 9.2. report.html

* генерируется из тех же данных
* скриншоты показываются ссылками + превью

---

## 10. Тест‑план (минимальный smoke)

0. **UI‑smoke (обязательный):** открыть каждую вкладку/модуль при размере окна `1024x720` и убедиться, что нет наложений (см. §6.6.8).
1. net.preflight → Success
2. net.diagnostics → Success
3. http.functional (1 endpoint) → Success
4. ui.snapshot (1 URL) → скрин создан
5. Прогоны: открыть JSON/папку, повторить
6. Telegram: тестовое сообщение + уведомление о завершении

---

## 11. НФТ (нефункциональные требования)

* Надёжность: валидный report.json при любом исходе.
* Воспроизводимость: повтор прогона из истории восстанавливает конфиг+профиль.
* Производительность UI: лог ограничен, список виртуализирован.
* Портируемость: Windows/Linux, без хардкодов путей.
* Юзабилити: единый layout, без наложений, русские подписи.

---

## 12. Приложение A — требования к оформлению ПЗ (из корпоративного стандарта)

Минимум, который обязателен для ВКР:

* Структура: титульный, реферат (1–2 стр), содержание, введение (без нумерации), основная часть, заключение, источники, приложения.
* Формат A4.
* Поля: слева 20 мм, справа 10 мм, сверху 20 мм, снизу 20 мм.
* Абзац 10 мм, интервал 1.5.
* Шрифт Times New Roman или Arial, 12–14.
* Нумерация страниц арабскими цифрами, номер не ставится на титуле.

---

## 13. Дельта внедрения (что привести к TO‑BE в коде)

> Статус на 17.02.2026: ✅ Prompt 1–11 внедрены в код (сборка зелёная).

✅ 1) Добавить `PauseBetweenIterationsMs` во все слои и в snapshot. *(внедрено в код; UI‑layout доводим в Prompt 4)*
✅ 2) Реализовать модель `Parallelism = N workers` + `WorkerId/Iteration` в контексте и в отчётах. *(внедрено в код; RunItems/JSON проверяются тестами)*
✅ 3) Реализовать Stop (soft) отдельно от Cancel (hard) и корректную финализацию статусов. *(внедрено в код; UI‑кнопки уже разведены)*
✅ 4) Привести UI CRUD конфигов к `Загрузить/Сохранить/Удалить` (убрать «Перезаписать»). *(внедрено Prompt 10: unified CRUD + dirty-state/guard)*
5) UI‑артефакты по воркерам: `profiles/w{WorkerId}`, `screenshots/w{WorkerId}`.
✅ 6) `net.availability`: убрать legacy IntervalSeconds и циклы; использовать RunProfile Duration/Iterations + PauseBetweenIterationsMs. *(внедрено Prompt 7A)*
✅ 7) Telegram: settings.json + раздел настроек + уведомления onStart/onFinish/onError + progress-режимы (Off/EveryN/EveryTSeconds) с rate limit (Prompt 8A/8B/9).
✅ 8) `http.functional/http.performance/http.assets`: List+Details и DataGrid‑паттерны, русская валидация, детерминированные RunItems (Endpoint/Asset), MVP assert’ы. *(внедрено и зафиксировано в коде)*
9) Playwright баннер: показывать для всех UI‑модулей, кнопка установки Chromium через запуск Playwright CLI.
10) Прогоны: удалить прогон = БД + папка `runs/{RunId}` (с подтверждением).
11) Прогоны: фильтры (debounce), панель деталей, контекстное меню.
✅ 12) Везде, где есть таблица: внедрить TableToolbar + единые команды Add/Delete/Duplicate (+ Up/Down только там, где порядок важен). *(внедрено Prompt 11: wrap-safe toolbar и команды во всех целевых модулях)*
13) Валидация: единый стандарт отображения ошибок (LostFocus + на Старт/Сохранить) и блокировок.
14) Починить текущую ошибку спецификации (AS‑IS): смешение текста A2/ui.snapshot и C1/net.diagnostics в старых ветках — в TO‑BE секции разведены.

## 14. Глоссарий

* Модуль — функциональный блок, запускаемый оркестратором.
* Семейство — группа модулей (UI/HTTP/NetSec).
* Конфигурация — сохраняемый набор настроек модуля + профиля.
* Версия конфигурации — snapshot JSON на момент сохранения.
* Прогон — запуск конкретной версии конфигурации.
* RunItem — единый элемент результата.
* Артефакт — файл результата (json/html/log/screenshot).
* Worker — параллельный исполнитель.
* Preflight — предстартовая проверка.

## 15. Реализуемость в .NET 8 + Avalonia 11 (проверка спецификации) и вспомогательные средства

Этот раздел фиксирует: **что можно реализовать текущим стеком**, и какие *дополнительные* библиотеки/утилиты потребуются (если потребуются).

### 15.1. UI‑элементы Avalonia и реализация требований

#### 15.1.1. Таблицы и списки (Runs, шаги, цели, endpoints, assets)

Реализуемо средствами Avalonia:

* `DataGrid` — для таблиц (Runs, шаги/цели/assets).
* `ListBox` + панель деталей (Grid 2 колонки) — для паттерна List+Details (endpoints).
* Виртуализация для больших списков: `DataGrid`/`ListBox` с `VirtualizingStackPanel` (достаточно для Runs).

TableToolbar (§6.2.5):

* команды `ICommand` в ViewModel (CommunityToolkit.Mvvm) + биндинг кнопок.
* обработка `Del/Enter/Ctrl+C/Ctrl+V`: либо через `KeyBindings`, либо `InputElement.KeyDown` с маршрутизацией в VM.
* вставка TSV/CSV: реализуется через `IClipboard` (Avalonia) + парсер строк.

#### 15.1.2. Фильтры с debounce (вкладка Прогоны)

Реализуемо без внешних библиотек:

* `CancellationTokenSource` + `Task.Delay(debounceMs)` в setter’е поисковой строки.
* обновление коллекции через `Dispatcher.UIThread.Post`.

Примечание: Rx не используем.

#### 15.1.3. Диалоги подтверждения/ошибок

Базово реализуемо стандартными окнами Avalonia:

* простые `Window`/`Dialog` (с return bool) для подтверждений.

Примечание: используем простые диалоги на Avalonia (без сторонних UI‑библиотек).

#### 15.1.4. Выбор папок/файлов и открытие артефактов

Реализуемо:

* File/Folder pickers: `Avalonia.Storage`.
* Открыть папку/файл: `ProcessStartInfo { UseShellExecute = true }`.

#### 15.1.5. Лог‑дровер и копирование

Реализуемо:

* `Expander` + `ListBox/ItemsControl`.
* Ограничение на 500 сообщений — в ViewModel (кольцевой буфер).
* Копирование в буфер: `IClipboard`.

#### 15.1.6. Прогресс и фоновые потоки

Реализуемо:

* оркестратор работает в background Task.
* обновление UI через `Dispatcher.UIThread.Post` (или через `IProgress<T>` + marshaling).

### 15.2. Движок тестов и фоновые сервисы

#### 15.2.1. Orchestrator, Parallelism, Stop/Cancel

Реализуемо в .NET:

* `Task.Run` + `SemaphoreSlim`/worker‑loop.
* `Stop` — отдельный флаг (`volatile bool`/`CancellationTokenSource` soft) + правило «не начинать новую итерацию».
* `Cancel` — общий `CancellationTokenSource.Cancel()`.

#### 15.2.2. Playwright/Chromium: установка из UI

Особенность: Playwright требует установки браузеров.

Реалистичный путь (без «магии»):

* хранить рядом с приложением скрипты `playwright.ps1/.sh` (или вызывать `Microsoft.Playwright.CLI`).
* по нажатию «Установить Chromium» запускать отдельный процесс установки и показывать вывод в UI.
* перед запуском процесса выставлять `PLAYWRIGHT_BROWSERS_PATH={DataDirectory}/browsers`, чтобы браузеры попадали в `BrowsersDirectory`.

Дополнительно может потребоваться:

* обработка прав на Linux (зависимости chromium). Это фиксируется в README/Help, а в UI — показываем сообщение при ошибке установки.

#### 15.2.3. Telegram

Реализуемо без внешних библиотек:

* отправка через `HttpClient` к Telegram Bot API.

Rate‑limit реализуется собственным сервисом (очередь + задержка `RateLimitSeconds`).

#### 15.2.4. SQLite

Реализуемо:

* `Microsoft.Data.Sqlite` (уже в стеке).

Примечание: для MVP используем прямой SQL (без Dapper).

### 15.3. Проверка «на реализуемость» и корректировки спецификации

1. Все элементы, описанные в §6 (таблицы, фильтры, контекстные меню, панель деталей) реализуемы в Avalonia 11.
2. Copy/Paste строк в таблицы требует явной обработки клавиш и буфера — это не «из коробки», но реализуемо.
3. Установка Chromium из UI требует запуска внешнего процесса Playwright CLI/скрипта — это предусмотрено и реалистично.
4. HTML‑отчёт:

   * можно сгенерировать простым шаблоном (string builder) без доп. библиотек.
   * для MVP генерируем HTML простым шаблоном (string builder) без сторонних шаблонизаторов.

## 16. Риски реализации и меры

* Риск: Playwright/Chromium установка на Linux (зависимости) → решение: явные инструкции + диагностика ошибки.
* Риск: UI зависнет при больших объёмах логов/прогонов → решение: лимит логов, виртуализация списка прогонов.
* Риск: сложность биндинга DataGrid → решение: унификация field‑row и TableToolbar + тестовые конфиги.

## 17. Wireframes (ASCII) — предварительный дизайн для Codex (источник правды)

Цель: дать Codex **детерминированную** схему расположения элементов, чтобы избежать наложений/кривых адаптивных сценариев.

### 17.1. Главное окно

```
┌──────────────────────────────────────────────────────────────────────────────┐
│  [DB: OK] [Telegram: Выкл/OK/Ошибка] [Playwright: OK/Не установлен]  [⚙ Настройки] │
├──────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────── Tabs ────────────────────────────────────────────────────┐ │
│  │ UI тестирование │ HTTP тестирование │ Сеть и безопасность │ Прогоны     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  (Внутри вкладки)                                                            │
│                                                                              │
├──────────────────────────────────────────────────────────────────────────────┤
│  ▾ Лог (Expander)   [Автопрокрутка ☑] [Копировать] [Очистить]                │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ последние ~500 сообщений…                                               │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────────┘
```

Правила:

* Лог‑дровер расположен внизу и не влияет на основную вёрстку вкладок.
* Статус‑панель сверху всегда видима.

### 17.2. ModuleWorkspace (любой модуль, кроме «Прогоны»)

```
┌────────────────────────────── ModuleWorkspace ──────────────────────────────┐
│ [Banner: Chromium не установлен] (показывается только в UI‑семействе)       │
├─────────────────────────────────────────────────────────────────────────────┤
│  ScrollViewer (один на вкладку)                                             │
│  ┌────────────── Карточка: Конфигурация ───────────────┐                    │
│  │ [Combo: Конфигурация ▼]  [Загрузить] [Сохранить] [Удалить]               │
│  │ Имя* [_____ ]  Итоговое имя [readonly]  Описание [__________]            │
│  └──────────────────────────────────────────────────────┘                    │
│  ┌────────────── Карточка: Настройки модуля ───────────┐                    │
│  │ FieldBlock… / DataGrid (если таблица) + TableToolbar │                    │
│  └──────────────────────────────────────────────────────┘                    │
│  ┌────────────── Карточка: Профиль запуска ────────────┐                    │
│  │ Mode (Iterations/Duration) + числовые поля (grid 2 col)                   │
│  │ Flags: Html, ScreenshotPolicy, TelegramNotify, Preflight…                 │
│  └──────────────────────────────────────────────────────┘                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  RunPanel: [Старт] [Стоп] [Отмена]  Status…  Progress…  [Папка] [JSON] [HTML] │
└─────────────────────────────────────────────────────────────────────────────┘
```

Правила:

* Карточки центрируются, `MaxWidth=1100`, наружный `PagePadding=16`.
* Кнопки в любых панелях — `WrapPanel` с переносом на 2‑ю строку.

### 17.3. Вкладка «Прогоны»

```
┌──────────────────────────────────── Прогоны ────────────────────────────────┐
│ Фильтры: [Поиск _______] [Модуль ▼] [Статус ▼] [Период ▼] [Только ошибки ☐]  │
│ Действия: [Открыть папку] [JSON] [HTML] [Повторить запуск] [Удалить] [RunId] │
├─────────────────────────────────────────────────────────────────────────────┤
│  Grid (Rows: * / splitter / *)                                               │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ DataGrid: список прогонов                                                │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│  ─────────────── GridSplitter (горизонтальный) ────────────────────────────  │
│  ▾ Детали (Expander)                                                         │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ FinalName + RunId (copy)  Summary…  Artifacts…  Top errors…             │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────────┘
```

Правила:

* Детали по умолчанию **видимы**, но могут быть свернуты Expander’ом.
* Двойной клик по строке — открыть `report.json`.

---

## 18. Как работать с Codex по этому документу (план, количество промптов, ограничения)

Цель: получить контролируемые изменения без «огромного коммита», чтобы результат был предсказуемым и компилируемым после каждого шага.

### 18.1. Базовые правила для Codex (обязательные)

1. Источник правды — `docs/INDEX.md` (этот документ). Не «додумывать» UX, если не описано.
2. Не добавлять NuGet‑зависимости и не менять целевую платформу/стек.
3. Делать изменения **пакетами** (маленькими), с обязательной проверкой `dotnet build` после каждого пакета.
4. Любой UI‑рефактор должен удовлетворять UI‑smoke (§6.6.8) на `1024x720`.
5. Не трогать файлы вне оговорённого scope.
6. Любые изменения схемы SQLite — сначала правка этого документа (INDEX), затем код.

### 18.2. Стратегия: серия промптов (актуальный план)

Промпты должны быть «узкими»: чёткая цель, чёткий список файлов, чёткие acceptance criteria.

**Prompt 0 — старт нового чата Codex (bootstrap + контроль соответствия INDEX)**

* Цель: убедиться, что Codex видит *актуальное состояние репозитория*, выполнить сборку/тесты/линт и дать «delta map» AS‑IS→TO‑BE по этому документу.
* Acceptance: `dotnet restore`, `dotnet build -c Release`, `dotnet test -c Release`, `bash scripts/lint-avalonia.sh`.

**Prompt 1 — (DONE) Стабилизация сборки и устранение дефектов XAML/биндингов**

* Цель: зелёная сборка и отсутствие компиляторных ошибок/варнингов.

**Prompt 2 — (DONE) Контракт отчётов и run folder (`report.json` + `moduleSettings`)**

* Цель: `report.json` всегда, `moduleSettings` обязателен, unit‑tests фиксируют контракт.

**Prompt 3 — (DONE) Оркестратор: workers/iterations, pause, stop/cancel, статусы**

* Цель: корректная семантика Stop vs Cancel, `workerId/iteration` в RunItems и `report.json`.

**Prompt 4 — (DONE) UI layout anti‑overlap по §6/§17**

* Цель: отсутствие наложений на `1024x720`, переносимые панели кнопок через WrapPanel + `wrap-gap`, один ScrollViewer на форму.

**Prompt 5 — (DONE) UI‑семейство (ui.scenario/ui.snapshot/ui.timing) MVP + Playwright UX**

* Цель: баннер/кнопка установки Chromium на всех UI‑модулях, корректные скриншоты по policy, toolbars Add/Delete/Duplicate.

**Prompt 6 — (DONE) HTTP‑семейство (functional/performance/assets)**

* Цель: строгая русская валидация, List+Details (functional/performance), DataGrid (assets), детерминированные RunItems kind=Endpoint/Asset, MVP assert’ы.

**Prompt 7A — (DONE) NetSec‑семейство (net.diagnostics / net.availability / net.security / net.preflight)**

* Цель: довести логику модулей и валидацию до §8.C, сделать детерминированные RunItems kind=Check/PreflightCheck, обновить report writer при необходимости.
* Non‑goals: без крупного UI‑рефактора Runs tab (это в 7B).

**Prompt 7B — Вкладка «Прогоны» (Runs) + Repeat/Delete/Open по §6.4**

* Цель: фильтры (включая период/только ошибки + debounce), детали (Expander), действия, double‑click → report.json, Repeat Run читает `runs/{RunId}/report.json` first.

**Prompt 8 — Финальный polish (необязательный, но рекомендованный)**

* Цель: примеры конфигураций, улучшение help/tooltip, дополнительный smoke‑набор, проверка локально на Windows/Linux.

### 18.3. Структура каждого промпта (шаблон)

Каждый промпт для Codex должен содержать:

* **Context:** «Открой `docs/INDEX.md` и следуй ему как TO‑BE».
* **Goal:** 1–3 буллета, измеримые.
* **Scope (Files):** перечисление папок/файлов, которые разрешено менять.
* **Non‑goals:** что нельзя делать (deps, редизайн вне §17, переписывание архитектуры).
* **Acceptance criteria:** компиляция + список ручных кликов для проверки.
* **Notes:** ссылки на разделы INDEX (например §6.6, §8.B1).

### 18.4. Как «направлять» Codex на INDEX.md

Рекомендуемая формулировка в каждом промпте:

* «`docs/INDEX.md` — единственный источник правды. Любые решения по UI/UX/параметрам должны быть взяты из него. Если находишь противоречие с кодом — исправляй код, а не документ.»
* «Если в INDEX чего‑то нет — не добавляй; вместо этого оставь TODO‑комментарий в коде и добавь запись в раздел «Журнал изменений» в конце этого файла (как вопрос/долг).»

---

## 19. Журнал изменений (внутри единого документа)

> Формат: дата — версия — кратко, что изменилось в спецификации/каноне.

* 17.02.2026 — v3.24 — Prompt 11: внедрён каноничный TableToolbar (WrapPanel + `wrap-gap`) для коллекций ui/http/net, добавлены/выравнены команды Add/Delete/Duplicate (и Up/Down только для `ui.scenario`), добавлены оффлайн unit-тесты на команды.
* 17.02.2026 — v3.23 — Prompt 10: внедрён каноничный Config CRUD (`Загрузить/Сохранить/Удалить`) для ModuleWorkspace, добавлен dirty-state индикатор и guard-подтверждение при потере несохранённых изменений.
* 17.02.2026 — v3.22 — Prompt 9: добавлены Telegram progress-уведомления в режимах `Off/EveryN/EveryTSeconds` с гейтингом per-run и `RateLimitSeconds` (через `TimeProvider`), безопасной обработкой ошибок и оффлайн unit-тестами.
* 17.02.2026 — v3.20 — Prompt 8B: Telegram-уведомления запусков доведены до TO-BE (gating глобальными флагами и профилем, безопасная отправка без падения run, rate limit через `RateLimitSeconds`, индикатор `Выкл/Ок/Ошибка` в верхней панели, оффлайн unit-тесты маршрутизации и rate-limit).
* 17.02.2026 — v3.19 — Prompt 8A: реализован MVP Telegram Settings (UI в SettingsWindow, персистентность в settings.json, тестовая отправка через TelegramClient/ITelegramClient с безопасной обработкой ошибок, оффлайн unit-тесты клиента).
* 17.02.2026 — v3.18 — реализация TO-BE для Prompt 7A: NetSec-модули доведены до §8.C (русская валидация, детерминированные Check/PreflightCheck результаты с workerId/iteration/itemIndex, severity для security baseline, обновление сериализации report.json для severity/metrics).
* 17.02.2026 — v3.17 — реализация TO-BE для Prompt 6 в коде: HTTP functional/performance/assets приведены к §8.B (русская валидация, List+Details для functional/performance, DataGrid + Duplicate для assets, kinds Endpoint/Asset, MVP assert’ы и itemIndex/metrics в report.json).
* 17.02.2026 — v3.16 — актуализация под завершение Prompt 6: HTTP‑семейство (валидации, List+Details/DataGrid, детерминированные RunItems), уточнён план (Prompt 7 разбит на 7A/7B), убраны ссылки на внешние документы: этот файл самодостаточный.
* 17.02.2026 — v3.15 — фиксация результатов Prompt 4–5: anti‑overlap UI wireframe, Playwright UX (browsers path + install banner), toolbars для UI‑семейства.

---

**Конец документа.**
